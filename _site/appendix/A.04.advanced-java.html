<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="この章では、より発展的な Java の活用と実践について簡単に解説します。" />
    <meta name=viewport content="width=device-width, initial-scale=1">
    <!-- ogp for twitter -->
    <meta content="@mixi_engineers" name="twitter:site" />
    <meta content="summary" name="twitter:card" />
    
    <meta content="Javaの活用 - mixi-inc/AndroidTraining" name="twitter:title" />
    
    <meta content="この章では、より発展的な Java の活用と実践について簡単に解説します。" name="twitter:description" />
    <meta content="/assets/logo.png" name="twitter:image:src" />
    <!-- ogp -->
    <meta content="mixi-inc/AndroidTraining" property="og:site_name" />
    <meta content="article" property="og:type" />
    <meta content="/assets/logo.png" property="og:image" />
    
    <meta content="Javaの活用 - mixi-inc/AndroidTraining" name="og:title" />
    
    <meta content="/appendix/A.04.advanced-java.html" property="og:url" />
    <meta content="この章では、より発展的な Java の活用と実践について簡単に解説します。" property="og:description" />
    
    <meta name="keyword" content="android, training, 基礎, スキル, 開発, developer, プログラミング, java" />
    

    <meta name="go-import" content="github.com/mixi-inc/AndroidTraining git https://github.com/mixi-inc/AndroidTraining.git">
    <script src="/AndroidTraining/bower_components/webcomponentsjs/webcomponents.js"></script>
    
    <link rel="stylesheet" type="text/css" media="screen" href="/AndroidTraining/stylesheets/main.css">
    <link rel="shortcut icon" href="/AndroidTraining/assets/favicon.ico" />
    <link rel="import" href="/AndroidTraining/bower_components/paper-scroll-header-panel/paper-scroll-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-drawer-panel/paper-drawer-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-header-panel/paper-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-toolbar/paper-toolbar.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-menu/paper-menu.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-item/paper-item.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-icon-button/paper-icon-button.html">
    <link rel="import" href="/AndroidTraining/bower_components/iron-icons/iron-icons.html">
    <style is="custom-style">
        paper-scroll-header-panel:not([style-scope]):not(.style-scope) {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        paper-toolbar.tall .bottom:not([style-scope]):not(.style-scope) {
            font-size: 40px;
            margin-left: 60px;

            -webkit-transform-origin: left center;
            transform-origin: left center;
        }

        .content:not([style-scope]):not(.style-scope) {
            padding: 8px;
        }

        .spacer:not([style-scope]):not(.style-scope) {
            -ms-flex: 1 1 0.000000001px;
            -webkit-flex: 1;
            flex: 1;
            -webkit-flex-basis: 0.000000001px;
            flex-basis: 0.000000001px;
        }

    </style>
    <title>Javaの活用 - mixi-inc/AndroidTraining</title>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-50931519-13', 'auto');
    ga('send', 'pageview');
    </script>
  </head>

  <body itemscope itemtype="http://schema.org/Article" fullbleed layout vertical>

    <paper-drawer-panel selected="main" >
      <!-- MENU -->
      <paper-header-panel mode="seamed" drawer class="drawer">
        <nav>
    <ol class="chapter_navigation">
        <a href="/AndroidTraining/">Home</a>
        <li>まえがき</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/introductions/1.01.about-android-os.html">Android-OSについて</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.02.prepare-for-development.html">開発環境の準備</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.03.create-project-for-android-studio.html">プロジェクトの作成</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.04.basic-knowledge.html">Androidの基礎知識</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.05.how-to-build-for-gradle.html">Android のビルドについて(Gradle)</a></li>
            
        </ol>
        <li>基礎編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/fundamentals/2.01.create-layout.html">アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.02.activity-and-fragment.html">ActivityとFragment</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.03.application-resource-management.html">アプリのリソース管理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.04.messaging-and-notification.html">メッセージングと通知</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.05.actionbar-and-interaction-control.html">AppBarとインタラクション制御</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.06.listView-and-viewPager.html">ListViewとViewPager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.07.serialize-and-collection-and-perpetuation.html">直列化とコレクション、永続化</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.08.async-processing.html">非同期処理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.09.network-access.html">ネットワーク通信</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.10.database.html">データベース</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing-for-android-studio.html">テスト(AndroidStudio)</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing.html">テスト</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.12.handler-and-looper.html">HandlerとLooper</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.13.webView.html">WebView</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.14.accountmanager.html">AccountManager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.15.advance-contentprovider.html">ContentProviderの発展</a></li>
            
        </ol>
        <li>実務編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-eclipse.html">デバッグと自動ビルド(Eclipse)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-gradle.html">自動ビルド(Android Studio)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.02.architecture-and-di.html">アーキテクチャ設計と DI</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.03.advanced-layout.html">続・アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.04.user-interface.html">ユーザインタフェース設計</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.05.security.html">セキュリティ</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.06.google-api.html">Google API</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.07.google-play-services.html">Google Play Services</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.08.cloud-sync.html">クラウド同期</a></li>
            
        </ol>
        <li>デザイナー編</li>
        <ol>
        </ol>
    </ol>
    <ol class="appex_navigation">
        <li>付録</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/appendix/A.01.import-from-git-for-eclipse.html">Git リポジトリからのプロジェクトのインポート</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.02.basic-java.html">Java の文法の基礎</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.03.how-to-create-avd.html">仮想デバイスの作成</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.04.advanced-java.html">Javaの活用</a></li>
            
        </ol>
    </ol>
</nav>

      </paper-header-panel>
      <paper-scroll-header-panel main condenses>
        <!-- HEADER -->
        <paper-toolbar class="mainheader tall" role="toolbar">
    <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>

    <span class="title"></span>

    <a id="forkme_banner" href="https://github.com/mixi-inc/AndroidTraining" role="button">
        <paper-icon-button src="/AndroidTraining/images/blacktocat.png"></paper-icon-button> <span>View on GitHub</span>
    </a>

    <div class="middle title">mixi-inc/AndroidTraining</div>
    <div class="bottom title">Javaの活用</div>
</paper-toolbar>


<div id="description" itemprop="description">この章では、より発展的な Java の活用と実践について簡単に解説します。</div>



        <!-- MAIN CONTENT -->
        <div id="main_content_wrap" class="content outer" itemprop="articleBody">
          <section id="main_content" class="inner">
            <p>数々の API の使い方と合わせて、様々なプラクティスやイディオムについても含まれます。</p>

<p>参考：<a href="http://amzn.to/Sr8iPe">Effective Java</a></p>

<h2 id="section">目次</h2>

<ul>
  <li><a href="#マルチスレッド">マルチスレッド</a>
    <ul>
      <li>スレッドプール</li>
      <li>原子性と可視性</li>
      <li>スレッドセーフ</li>
      <li>遅延初期化
        <ul>
          <li>スレッドセーフでない実装</li>
          <li>Double Checked Locking</li>
          <li>Initialization-on-demand Holder</li>
        </ul>
      </li>
      <li>同期化を支援する仕組み
        <ul>
          <li>CountDownLatch</li>
          <li>CyclicBarrier</li>
          <li>Semaphore</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#データ構造">データ構造</a>
    <ul>
      <li>ミュータブルとイミュータブル</li>
      <li>Defensive Copying</li>
      <li>Builder パターン</li>
      <li>Cloneable</li>
      <li>Serializable</li>
      <li>float と double</li>
    </ul>
  </li>
  <li><a href="#参照の管理">参照の管理</a>
    <ul>
      <li>内部クラス</li>
      <li>static フィールド</li>
      <li>WeakReference</li>
      <li>WeakHashMap</li>
    </ul>
  </li>
  <li><a href="#列挙型の活用">列挙型の活用</a>
    <ul>
      <li>Singleton パターン</li>
      <li>Strategy パターン</li>
      <li>Enum Factory パターン</li>
      <li>列挙型とコレクションフレームワーク</li>
      <li>列挙型とパフォーマンス</li>
    </ul>
  </li>
  <li><a href="#アノテーション">アノテーション</a>
    <ul>
      <li>標準アノテーションの使用
        <ul>
          <li>@Override</li>
          <li>@SuppressWarnings</li>
          <li>@Deprecated</li>
        </ul>
      </li>
      <li>その他のアノテーションの使用
        <ul>
          <li>@Nullable</li>
          <li>@NotNull</li>
          <li>@Inject</li>
          <li>@Test</li>
          <li>@Ignore</li>
          <li>@RunWith</li>
          <li>@Before</li>
          <li>@After</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#例外">例外</a>
    <ul>
      <li>標準実行時例外の使用
        <ul>
          <li>ArithmeticException</li>
          <li>ArrayIndexOutOfBoundsException</li>
          <li>ClassCastException</li>
          <li>IllegalArgumentException</li>
          <li>IllegalStateException</li>
          <li>NullPointerException</li>
          <li>NumberFormatException</li>
          <li>StringIndexOutOfBoundsException</li>
          <li>UnsupportedOperationException</li>
        </ul>
      </li>
      <li>例外のラップ</li>
      <li>エラーアトミック性</li>
    </ul>
  </li>
  <li><a href="#New I/O">New I/O</a>
    <ul>
      <li>バッファ</li>
      <li>チャネル</li>
    </ul>
  </li>
  <li><a href="#New I/O2">New I/O2</a>
    <ul>
      <li>非同期チャネル</li>
    </ul>
  </li>
</ul>

<h2 id="section-1">マルチスレッド</h2>

<h3 id="section-2">スレッドプール</h3>

<p>Android を始めとして、各種の GUI を構築するアプリケーションでは、UI Thread(Main Thread) をブロックする各種の処理のためのスレッド(Worker Thread)を用いた非同期処理を実装する。</p>

<p>UI のイベントに応じてネットワークやデータベース等へアクセスする頻度が高いアプリケーションの場合、イベントが発生するごとに新規に<code class="highlighter-rouge">Thread</code>を立ち上げて動作させると、パフォーマンスの問題が発生する。</p>

<p>そこで、ある程度<code class="highlighter-rouge">Thread</code>のインスタンスをプールしておき、適宜インスタンスを使いまわしていく仕組みとして、<code class="highlighter-rouge">ThreadPoolExecutor</code>を用いる。</p>

<p>この仕組は Android の標準の非同期処理フレームワークである<code class="highlighter-rouge">AsyncTask</code>でも用いられている。</p>

<p><code class="highlighter-rouge">TODO: Sample code here</code></p>

<h3 id="section-3">原子性と可視性</h3>

<p>原子性(アトミック性)とは、あるスレッド上での、あるデータへの複数の操作が、他のスレッドからみて単一の操作に見えること。データの状態遷移の過渡的な不整合な状態が見えない性質とも言う。</p>

<p>Java のプリミティブ型のうち、long と double 以外の型の操作は原子性が保証されている。long と double は 64bit のデータで、その読み書きの際に複数の操作が発生するため原子性が保証されない。</p>

<p>一方で、int 等の整数のインクリメント操作やデクリメント操作の記法(<code class="highlighter-rouge">count++;</code>や<code class="highlighter-rouge">count--;</code>)は、その操作の中に複数の操作(読み取り、加算or減算、書き込み)を含むため、原子性が保証されない。</p>

<p>64 bit データの操作やインクリメント・デクリメント操作の原子性を保証するには、synchronized による同期化をするか、<code class="highlighter-rouge">AtomicInteger</code>クラスなどの原子性を保証する操作を実現するラッパークラスを使用する。</p>

<p>可視性とは、どのスレッドからでも同じ値が見えること。</p>

<p>通常、スレッドを複数立ちあげると、変数の値はスレッドごとにキャッシュされる仕組みになっている。このため、スレッドごと値の更新と参照に不整合が起こることがある。</p>

<p>同期化では、この原子性と可視性の両方を保証する必要がある。</p>

<p><code class="highlighter-rouge">volatile</code>修飾子は可視性を保証し、どのスレッドからでも同じ値を見えるように、スレッドごとのキャッシュを使わないようにする。</p>

<h3 id="section-4">スレッドセーフ</h3>

<p>スレッドセーフであるとは、以下の条件を満たすこと。</p>

<ul>
  <li>インスタンスに対する操作をどんな順番で実行しても正しく振る舞う。</li>
  <li>複数のスレッドからの操作も同様に、どんな順番で実行しても正しく振る舞う。</li>
</ul>

<p>順番が入れ替わると破綻したり、複数スレッドから操作を行う際、順番が狂うと破綻する操作をスレッドセーフでない操作という。</p>

<p>スレッドセーフにはレベルが有り、クラスの性質から幾つかのレベルに分類され、レベルによって使う側の同期の必要性の有無を判断する。</p>

<ul>
  <li>不変
状態を持たないもの。イミュータブルなオブジェクトは使う側で同期化する必要がない。</li>
  <li>無条件スレッドセーフ
使う側で特別同期化をしなくてもよいもの。</li>
  <li>条件付きスレッドセーフ
一部に、使う側で同期化が必要な操作を含むもの。</li>
  <li>スレッドセーフでない
同期化をしていないもの。</li>
  <li>敵対
マルチスレッドで使えないもの。</li>
</ul>

<h3 id="section-5">遅延初期化</h3>

<p>通常、メンバ変数の初期化はコンストラクタで行う。しかし、コンストラクタでの処理がパフォーマンスに影響をおよぼす場合、メンバ変数を、それが必要になった時に初めて初期化をするようにすることで、コンストラクタのパフォーマンスを向上させることが出来る。このようなチューニングのノウハウを遅延初期化と言う。</p>

<p>遅延初期化は、シングルトンパターンの実装にも見られる。</p>

<p>このイディオムは、マルチスレッドで正しく動作させるために工夫が必要になるため、特に理由のない限り、必要なければ使わないことが推奨されている。</p>

<h4 id="section-6">スレッドセーフでない実装</h4>

<p>メンバ変数を、必要になったタイミングで初期化する単純な実装は以下のとおり。</p>

<pre><code class="language-Java">public class LazyInitializationSample {
    private Map&lt;String, Object&gt; mMap;

    public LazyInitializationSample() {} // コンストラクタで初期化しない

    public void add(String key, Object data) {
        if (mMap == null) { // mMap を使う直前で初期化する
            mMap = new HashMap&lt;String, Object&gt;();
        }
        mMap.put(key, data);
    }
}
</code></pre>

<p>この実装は、単一のスレッドで使用する場合には問題ないが、複数のスレッドから<code class="highlighter-rouge">LazyInitializationSample</code>のインスタンスを操作しようとするときに問題を発生させる可能性がある。</p>

<p>ひとつには、<code class="highlighter-rouge">HashMap</code>の中のデータの操作が同期化されないため、結果が不定となること。<br />
もうひとつは、<code class="highlighter-rouge">mMap</code>の初期化処理が同期化されないため、これも結果が不定となること。</p>

<p>いずれにしても、スレッドセーフでない操作が含まれるため、予期せぬ動作を招くことがある。</p>

<p>HashMap の中のデータの操作を同期化するには、<code class="highlighter-rouge">HashMap</code>ではなく<code class="highlighter-rouge">ConcurrentHashMap</code>を使用することで解決できる。<br />
スレッドセーフなコレクションは<code class="highlighter-rouge">java.util.concurrent</code>パッケージにいくつかの実装があるほか、<code class="highlighter-rouge">Collections</code>クラスのユーティリティメソッドを用いてスレッドセーフなコレクションを生成することも出来る。</p>

<pre><code class="language-Java">public class LazyInitializationSample {
    private Map&lt;String, Object&gt; mMap;

    public LazyInitializationSample() {} // コンストラクタで初期化しない

    public void add(String key, Object data) {
        if (mMap == null) { // mMap を使う直前で初期化する
            mMap = new ConcurrentHashMap&lt;String, Object&gt;();
        }
        mMap.put(key, data);
    }
}
</code></pre>

<p>上記の場合も、<code class="highlighter-rouge">mMap</code>の初期化がスレッドセーフではない。</p>

<p>よって、以下のようなイディオムを使用して、スレッドセーフな実装とする。</p>

<h4 id="double-checked-locking">Double Checked Locking</h4>

<p>null チェックを<code class="highlighter-rouge">synchronized</code>ブロックの外と内で二度行うことから、Double Checked と呼ばれる。</p>

<pre><code class="language-Java">public class LazyInitializationSample {
    private volatile Map&lt;String, Object&gt; mMap; // どのスレッドからも常に同じ値を見る(可視性)ことを保証

    public LazyInitializationSample() {}

    public void add(String key, Object data) {
        if (mMap == null) { // 既に初期化が終わっている場合はロックを取らず処理を継続
            synchronized (this) { // 自身のオブジェクトをミューテックスとしてロックを取得し、クリティカルセクションに突入
                if (mMap == null) {  // ロック解放待ちの間に mMap が初期化された場合は何もしないようにするためのチェック
                    mMap = new HashMap&lt;String, Object&gt;();
                }
            }
        }
        mMap.put(key, data);
    }
}
</code></pre>

<p>このイディオムを正しく動作させるためには、<code class="highlighter-rouge">volatile</code>の役割が欠かせない。
ただし、Java 1.4 と Java 1.5 で<code class="highlighter-rouge">volatile</code>の保証する範囲が異なり、Java 1.4 の <code class="highlighter-rouge">volatile</code>修飾子で保証する範囲では不足があるため、Java 1.4 以前でこのイディオムは正しく動作しない。</p>

<p>以下のように、シングルトンパターンの実装にも用いられる。</p>

<pre><code class="language-Java">public class Singleton {
    private static volatile Singleton sInstance;

    protected Singleton() {}

    public static void getInstance() {
        if (sInstance == null) {
            synchronized(Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }
}
</code></pre>

<h4 id="initialization-on-demand-holder">Initialization-on-demand Holder</h4>

<p><code class="highlighter-rouge">static</code>なフィールドが、クラスをロードしたタイミングで初期化されることと、<code class="highlighter-rouge">static</code>な内部クラスが、使用されるタイミングで初めてロードされることを利用したイディオム。<br />
クラスのロードは VM 上で逐次実行されることと、<code class="highlighter-rouge">static</code>なフィールドの初期化も逐次実行されることから、同期化のコードを書かなくてもよい。これにより、同期化に掛かるオーバヘッドも削減できるほか、Java のバージョンに依らず正しく動作する。</p>

<pre><code class="language-Java">public class LazyInitializedObject {
	private LazyInitializedObject() {}
 
	private static class LazyHolder {
		private static final LazyInitializedObject INSTANCE = new LazyInitializedObject();
	}
 
	public static LazyInitializedObject getInstance() {
		return LazyHolder.INSTANCE; // LazyHolder がロードされた時のみコンストラクタが呼ばれる
	}
}
</code></pre>

<h3 id="section-7">同期化を支援する仕組み</h3>

<p>ここでは、言語仕様以外に用意されている同期化のためのユーティリティの概要を説明する。</p>

<h4 id="countdownlatch">CountDownLatch</h4>

<p>カウンタが 0 になるまで待ち合わせをするためのオブジェクト。初期値に与えた数から開始し、<code class="highlighter-rouge">CountDownLatch#countDown()</code>を呼び出すことでカウンタをデクリメントする。待ち合わせは<code class="highlighter-rouge">CountDownLatch#await()</code>で行い、カウンタが 0 になったタイミングですべてのスレッドが待機状態から実行状態となる。</p>

<p><code class="highlighter-rouge">CountDownLatch</code>は再利用しない。再利用を前提とする場合は<code class="highlighter-rouge">CyclicBarrier</code>を使う。</p>

<p><code class="highlighter-rouge">TODO: sample code here</code></p>

<h4 id="cyclicbarrier">CyclicBarrier</h4>

<p>指定した数のスレッドが待ち合わせ箇所に到達するまですべてのスレッドを待機させるためのオブジェクト。初期値として、待ち合わせをするスレッド数を与え、<code class="highlighter-rouge">CyclicBarrier#await()</code>で待機する。指定した数のスレッドが<code class="highlighter-rouge">CyclicBarrier#await()</code>に到達した時点で、すべてのスレッドが待機状態から実行状態となる。</p>

<p><code class="highlighter-rouge">TODO: sample code here</code></p>

<h4 id="semaphore">Semaphore</h4>

<p>指定した数のスレッドのみが進入できるクリティカルセクションを作る仕組み。
<code class="highlighter-rouge">synchronized</code>ブロックは同時に 1 つのスレッドのみが進入できるが、Semaphore は指定した数の進入を許可する。数の指定を 1 とすることで<code class="highlighter-rouge">synchronized</code>ブロックと同等の排他制御が可能。</p>

<p><code class="highlighter-rouge">Semaphore#acquire()</code>によってロックを取得し、指定した回数このメソッドが呼ばれた段階で、以後の呼び出しがブロックされる。<code class="highlighter-rouge">Semaphore#release()</code>によってロックを開放する。</p>

<p><code class="highlighter-rouge">TODO: sample code here</code></p>

<h2 id="section-8">データ構造</h2>

<h3 id="section-9">ミュータブルとイミュータブル</h3>

<p>ミュータブルとは、オブジェクトの生成後にその状態を変更可能であることで、イミュータブルはその反対に、状態を変更できないこと。</p>

<p><code class="highlighter-rouge">final</code>修飾子は、参照を変更不可能にすることを保証するが、オブジェクトの状態を変更不可能にすることは保証しないことに注意する。</p>

<p>イミュータブルなオブジェクトは、生成後に状態の変更ができないため、複数のスレッドで同じイミュータブルなオブジェクトを使用している場合でも安全に使用できる。</p>

<h3 id="defensive-copying">Defensive Copying</h3>

<p>Java ではオブジェクトは参照によって共有されるため、ミュータブルなオブジェクトの参照を共有する場合、誰かがそのオブジェクトに変更を加えた時点で、すべての参照を共有している箇所にその変更の影響が波及してしまう。</p>

<p>以下の例では、初期化や状態の取得時にこの問題を誘発する。</p>

<pre><code class="language-Java">public class SomethingMutable {
    private final List&lt;Object&gt; mList; // 参照は書き換えられないが…

    public SomethingMutable(List&lt;Object&gt; list) {
        mList = list; // 参照をそのまま渡すので、コンストラクタの呼び出し側で、渡したリストを変更すると、その影響を受けてしまう
    }

    public List&lt;Object&gt; getList() {
        return mList; // 参照をそのまま返すので、このメソッドの呼び出し側で、返って来たリストを変更すると、その影響を受けてしまう
    }
}
</code></pre>

<p>フィールドが保持する参照が変更不可能であること意外にも、参照を通じた変更を許容しないことがイミュータブルであることの条件となるので、以下のように防御的コピーの手法を用いる。</p>

<pre><code class="language-Java">public class SomethingImmutable {
    private final List&lt;Object&gt; mList;

    public SomethingImmutable(List&lt;Object&gt; list) {
        mList = new ArrayList&lt;Object&gt;(list); // 別のオブジェクトの参照を保持することで、呼び出し側の変更の影響を受けないようにする(防御的コピー)
        // mList = Arrays.asList(list.toArray()); 配列に変換して再度 List 化する方法もある
    }

    public List&lt;Object&gt; getList() {
        return new ArrayList&lt;Object&gt;(mList); // 別のオブジェクトの参照を返すことで、呼び出し側の変更の影響を受けないようにする(防御的コピー)
        // return Collections.unmodifiableList(mList); // 変更不可能なコレクションを生成するユーティリティを使うことも可
    }
}
</code></pre>

<h3 id="builder-">Builder パターン</h3>

<p>多数のメンバ変数を持つオブジェクトを生成する際には、コンストラクタよりも Builder パターンを用いることが推奨されている。<br />
このパターンを用いて、イミュータブルなオブジェクトを生成する。</p>

<pre><code class="language-Java">public class Something {
    private final String mName;
    private final String mLocation;
    private final int mAge;
    private final Date mBirthday;

    private Something(Builder builder) {
        mName = builder.name;
        mLocation = builder.location;
        mAge = builder.age;
        mBirthday = builder.birthday;
    }

    public String getName() {
        return mName; // String はイミュータブルなので参照をそのまま返しても問題ない
    }

    public int getAge() {
        return mAge;
    }

    public Date getBirthday() {
        return new Date(mBirthday.getTime()); // Date はミュータブルなので、防御的コピーをする
    }

    // Something のビルダー
    public static class Builder {
        private final String name;
        private String location;
        private int age;
        private Date birthday;

        public Builder(String name) {
            this.name = name;
        }

        public Builder setLocation(final String value) {
            location = value;
            return this;
        }

        public Builder setAge(final int value) {
            age = value;
            return this;
        }

        public Builder setBirthday(final Date value) {
            birthday = new Date(value.getTime());
            return this;
        }

        public Something create() {
            return new Something(this);
        }
    }
}
</code></pre>
<p>### Cloneable</p>

<p>このインタフェースを実装したクラスは、自身のオブジェクトの複製を生成できることを保証する。<code class="highlighter-rouge">Cloneable</code>はそのためのマーカインタフェース。</p>

<p>もともと、<code class="highlighter-rouge">Object#clone()</code>というメソッドが定義されており、複製のためのメソッド自体は<code class="highlighter-rouge">Cloneable</code>インタフェースによって定義されるものではないが、<code class="highlighter-rouge">Cloneable</code>でないオブジェクトで<code class="highlighter-rouge">Object#clone()</code>を呼ぶと<code class="highlighter-rouge">CloneNotSupportedException</code>がスローされる。</p>

<p>また、<code class="highlighter-rouge">Object#clone()</code>は<code class="highlighter-rouge">protected</code>なメソッドであるが、<code class="highlighter-rouge">Cloneable</code>を実装したクラスでオーバライドする際は、アクセス修飾子を<code class="highlighter-rouge">public</code>にする必要がある。</p>

<p>これらのことから、<code class="highlighter-rouge">Cloneable</code>は自身のオブジェクトの複製を生成できることを保証するためのインタフェースではあるものの、その実生成を保証するためには、作成者による正規の手順での実装が求められる点に留意しなければならないため、もし、このインタフェースを実装しただけのクラスがあったとするならば、使用する側は、複製の生成は必ずしも成功するとは限らないことを意識しなければならない。</p>

<p>複製の生成を許可した際、一般的には、以下の式が期待値通りになることが普通であるが、絶対ではない。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">Something</span> <span class="n">original</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Something</span><span class="o">();</span>
<span class="n">Something</span> <span class="n">cloned</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">original</span> <span class="o">==</span> <span class="n">cloned</span><span class="o">);</span> <span class="c1">// オブジェクトの複製なので、参照が異なることから false</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="n">cloned</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">// オブジェクトの複製なので、型自体は同一であり、型情報は VM 上で唯一であることから true</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">original</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">cloned</span><span class="o">));</span> <span class="c1">// 複製直後の状態は同じになるので true だが、状態に変化があり、equals() と hashCode() で規定される条件が変われば false ともなり得る</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Object#clone()</code>の実体は<code class="highlighter-rouge">native</code>メソッドであり、内部的に<code class="highlighter-rouge">memcpy</code>を用いてオブジェクトのコピーを生成している(JVM, Dalvik)。このため、プリミティブ型データはそのまま深い複製(ディープコピー)の扱いとなるが、参照型は浅い複製(シャローコピー、オブジェクト自体を新規に生成せず、参照だけをコピーする)となる。基本的に、<code class="highlighter-rouge">Object#clone()</code>が生成するのは、浅い複製である。よって、何らかの参照型オブジェクトをフィールドに持つクラスで、ディープコピーをする必要がある場合には、別途そのためのメソッドの定義と実装を行う必要がある。このことで、ディープコピーを複製したオブジェクトのフィールドへセットする必要性から、フィールドが不変（<code class="highlighter-rouge">final</code>）とすることができなくなることもある。</p>

<p>また、<code class="highlighter-rouge">Cloneable</code>が保証するのは、自身の型のコピーを生成することなので、<code class="highlighter-rouge">Object#clone()</code>でコンストラクタを用いるのは間違いや混乱を生みやすい。</p>

<p>以下のように実装する。</p>

<pre><code class="language-Java">public Something implements Cloneable {
    private int mData;

    @Override
    public Something clone() {
        try {
            return (Something) super.clone();
        } catch (CloneNotSupportedException e) {
            // Cloneable であるならば起こり得ない例外
            throw new AssertionError("exception has been thrown unexpectedly.", e);
        }
    }
}
</code></pre>

<p>もしこの<code class="highlighter-rouge">Something</code>を継承する場合、以下のように実装する。</p>

<pre><code class="language-Java">public class AnotherThing extends Something {
    private long mTimestamp;

    @Override
    public AnotherThing clone() {
        return (AnotherThing) super.clone();
    }
}
</code></pre>

<p><code class="highlighter-rouge">AnotherThing#clone()</code>を呼び出した場合、親クラスのフィールドのみではなく、自分のクラスのフィールドもコピーされる。</p>

<p><code class="highlighter-rouge">Object#clone()</code>の戻り値が<code class="highlighter-rouge">Object</code>であるのに対し、各クラスの実装は、その型を戻り値としている。これは、Java 5 からの機能（共編戻り値型）であるので、1.4 以前の環境では正しくない。ただし、Java 5 以降の環境では正しく動作し、かつ、このような実装は推奨されるべきものとして、基本的なノウハウとなっている。</p>

<blockquote>
  <p>クライアントのためにライブラリーができることを、決してクライアントにさせてはいけない [Effective Java]</p>
</blockquote>

<p>この原則に従って、<code class="highlighter-rouge">clone()</code>を呼び出した側でキャストさせるのではなく、<code class="highlighter-rouge">clone()</code>の実装の中でキャストする。</p>

<p>参照型オブジェクトをフィールドに持つクラスを<code class="highlighter-rouge">Cloneable</code>にする場合、<code class="highlighter-rouge">String</code>型のようなイミュータブルなオブジェクト以外は、参照を共有してしまうことに危険が伴うことが多い。なぜなら、複製を作っても、参照するオブジェクトは同じであるので、カプセル化が容易に破壊されてしまう為である。使用者は、本来なら独立したオブジェクトであると思って様々な操作をすることが想定されるが、<code class="highlighter-rouge">Object#clone()</code>によるコピーは単なる参照のコピーなので、共有されたオブジェクトを操作してしまうことになる。また、プリミティブ型とはいえ、何らかのユニークなデータを保持するようなフィールドは、複製の生成時に書き換えられる必要が有る。これは完全にそのフィールドの表す意味に依存するため、プログラマが適切に判断して実装しなければならない。</p>

<p>このように、<code class="highlighter-rouge">Cloneable</code>と<code class="highlighter-rouge">Object#clone()</code>の実装は非常に複雑なので、コピーコンストラクタ(自身の型のオブジェクトを引数に持ち、そのオブジェクトからデータを取り出して自身のオブジェクトのフィールドにセットするコンストラクタ)やコピーファクトリーを検討することが望ましい。</p>

<p>最後に、<code class="highlighter-rouge">Object#clone()</code>もコピーコンストラクタも、マルチスレッド環境下における同期化は自分で実装する必要が有ることに留意する。</p>

<h3 id="serializable">Serializable</h3>

<p>このインタフェースを実装したクラスのオブジェクトが、一定のフォーマットに従って直列化（シリアライズ）出来ることを示すマーカインタフェース。フォーマットはプログラマが選択でき、文字列やバイト列などに変換されたり、文字列やバイト列などからオブジェクトに変換される。</p>

<p>直列化は、オブジェクトを特定のフォーマットへ変換することで、その逆はデシリアライズと呼ばれる。</p>

<p><code class="highlighter-rouge">enum</code>は言語仕様でシリアライズ可能とされ、プログラマが変換過程を意識せずともシリアライズの仕組みを利用できる。</p>

<p><code class="highlighter-rouge">Serializable</code>を実装したクラスのオブジェクトをシリアライズすることで、ファイルに出力する、ネットワークのストリームにのせる等の、外部とのやりとりが可能となるが、これにより、<code class="highlighter-rouge">Serializable</code>であるクラスはその全てが公開 API としての取り扱いをしなければならなくなる。よって、リリース後の<code class="highlighter-rouge">Serializable</code>を実装したクラスの変更コストは必然的に高くなる。</p>

<p><code class="highlighter-rouge">Serializable</code>なクラスを定義するコストには、変更後のクラスと変更前のクラスとの互換性を保つこと、コンストラクタ以外でのインスタンス生成に係るバグ・セキュリティホールへの対策、互換性テストがある。</p>

<p>あるクラスが<code class="highlighter-rouge">Serializable</code>で、そのシリアライズされたファイルが出力された後、そのクラスに変更があった場合、シリアライズされたファイルからデシリアライズを試みた時にも、正しくデシリアライズできること（互換性）を保つ必要がある。</p>

<p>Java のシリアライズの仕組みでは、<code class="highlighter-rouge">Serial Version UID</code>という、クラスごとに一意な番号を用いて、デシリアライズ時にどのクラスへ変換すべきかを判断している。この一意な番号は、特にプログラマが指定しない限り JVM によって実行時に生成される。この生成ロジックは、クラスに含まれるすべての<code class="highlighter-rouge">public</code>または<code class="highlighter-rouge">protected</code>なメンバーの影響を受けるため、それらのメンバが増えたり減ったりすると、JVM が実行時に生成する一意な番号も変わってしまう。
このため、<code class="highlighter-rouge">Serial Version UID</code>を明示的に宣言していない<code class="highlighter-rouge">Serializable</code>なクラスは、コンパイル時に警告を出力するようになっている。コンパイル前に自動でその番号を発行する仕組みが各種の IDE にも備わっているので、それを利用するか、自分で好きなものを選択することもできる。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Something</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="c1">// 自分で書いても良いし、IDE の仕組みを使ってもよい</span>
    <span class="c1">// 自分で宣言しないと実行時に計算されるため、パフォーマンスが落ちる</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">32425924334L</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>また、互換性を保つもう一つの仕組みとして、<code class="highlighter-rouge">ObjectOutputStream</code>や<code class="highlighter-rouge">ObjectInputStream</code>を拡張して、内部表現（メンバ変数の名前や型など）の変更に対応する方法もある。</p>

<p>いずれにしても、クラスへの変更が重なるほどに、互換性を保つためのコードを書く必要が生じ、それによるテストコストも増大するため、設計には特に細心の注意を払う。その意味で、継承を前提とするクラスを<code class="highlighter-rouge">Serializable</code>にすることは、拡張したクラスの実装も複雑かつ柔軟性の乏しい状態にしてしまうので、推奨されない。一方で、<code class="highlighter-rouge">Serializable</code>でないクラスを拡張したクラスを<code class="highlighter-rouge">Serializable</code>とする為には、小クラスからアクセスできるデフォルトコンストラクタが必要な点に注意しなければならない。</p>

<p>シリアライズの仕組みでは、コンストラクタを介さないでもオブジェクトを生成するので、特に、デシリアライズ時に、規定外のデータを読み込むことによるリスクを認識する必要がある。オブジェクトをシリアライズしてファイルに書きだした後に、そのファイルの中身が書き換えられたとしても、デシリアライズ後にオブジェクトが正しく動作するように設計・実装されなければならない。あるいは、デシリアライズに失敗して例外がスローされる場合を考慮する。</p>

<h3 id="float--double">float と double</h3>

<p>算術計算上、正確さを求められる場合、<code class="highlighter-rouge">float</code>や<code class="highlighter-rouge">double</code>の浮動小数点型の使用は避ける。これは、浮動小数点数の取り扱い方の問題で、0.1が正確に表すことができず、内部的にはその近似値を使用している為で、これによる誤差が生じるからである。</p>

<p>単位をより小さいものにすることで、整数値として表すことが出来る場合（メートル単位をミリメートル単位に落とす、秒単位をミリ秒単位に落とすなど）で、上限が<code class="highlighter-rouge">int</code>や<code class="highlighter-rouge">long</code>の範囲を超えないものであるなら、これらの整数型を使用するほうが望ましく、その範囲をも超える場合や、パフォーマンスの面で、多少の劣化が無視できるのであれば、<code class="highlighter-rouge">BigDecimal</code>を使用することが推奨される。</p>

<p>また、Android においては、デバイスのプロセッサに除算器を持たないものがあり、除算をソフトウェアで動作させているものがある。ハードウェアで除算するよりも格段にスピードが劣化するので、可能ならば整数型を用いることが推奨される。</p>

<h2 id="section-10">参照の管理</h2>

<h3 id="section-11">内部クラス</h3>

<p>Java には、内部クラスの定義の仕方によって 2 種類の内部クラスがある。</p>

<pre><code class="language-Java">class OuterClass {
    private String mSomeData;

    public void doSomething(NestedClass nested) {
        System.out.println(nested.mAnotherData); // static な内部クラスのインスタンスのフィールドは private でもアクセスできる
    }

    public class InnerClass {
        public void doSomething() {
            System.out.println(mSomeData); // 内部クラスの外側のクラスのフィールドは内部クラスからアクセスできる
        }
    }

    public static class NestedClass {
        private OuterClass mInstance;
        private String mAnotherData;

        public void doSomething() {
            System.out.println(mInstance.mSomeData); // 内部クラスの外側のクラスのフィールドは、インスタンスを経由すれば private でもアクセスできる
        }
    }
}

public class Consumer {
    public static void main(String[] args) {
        OuterClass.InnerClass inner = new OuterClass().new InnerClass();
        OuterClass.NestedClass nested = new OuterClass.NestedClass();
    }
}
</code></pre>

<p><code class="highlighter-rouge">static</code>でない内部クラス(インナークラス)の場合、暗黙のうちに外側のクラスへの参照を持つ。
この特徴から、あるインスタンスを複数のインスタンスが共有する場合に有用なものとなる。<br />
一方で、そのインナークラスのインスタンスへの参照があるかぎり、その外側クラスのインスタンスも開放されなくなるため、メモリリークを誘発しやすくもある。</p>

<h3 id="static-">static フィールド</h3>

<p><code class="highlighter-rouge">static</code>なフィールドは、ガーベジコレクションの対象とはならず、初期化後はメモリ上に存在し続ける。</p>

<p>この時、以下の様に、コレクションを<code class="highlighter-rouge">static</code>なフィールドとして保持すると、メモリリークの原因となり得る。</p>

<pre><code class="language-Java">public class LeakCollectionHolder {
    // 保持するデータがずっと参照され続けるため、コレクションの中身をクリアするか、コレクションそのものを null としないかぎり GC されなくなる
    private static List&lt;String&gt; LIST = new ArrayList&lt;String&gt;();

    public void addToList(String data) {
        LIST.add(data);
    }
}
</code></pre>

<h3 id="weakreference">WeakReference</h3>

<p>Java の参照には強さがあり、通常なにもしないと強参照となり、参照が切れた時点ではじめて GC の対象となる。</p>

<p>しかし、オブジェクトの循環参照を起こすと、互いに参照が保持されるために GC の対象とならず、メモリリークの原因となる。<br />
このような状況を防ぐため、参照の強さを弱め、弱い参照からのみ参照されるオブジェクトは GC による回収の対象とする仕組みが用意された。</p>

<p>このような、弱い参照を実現するためのクラスが<code class="highlighter-rouge">WeakReference</code>である。</p>

<pre><code class="language-Java">public class Something {
    private NestedClass mNested;

    public Something() {
        mNested = new NestedClass(this);
    }

    public static class NestedClass {
        private WeakReference&lt;Something&gt; mSomething; // Something 型のオブジェクトへの弱参照を保持するメンバ変数

        public NestedClass(Something something) {
            mSomething = new WeakReference&lt;Something&gt;(something); // 弱参照の初期化
        }

        public void doWithSomething() {
            Something something = mSomething.get(); // 弱参照から実際の強参照を得る
            if (something == null) { // Something オブジェクトへの参照が回収済みの場合
                return; // 既に GC されている場合は何もしない
            }
            // 以後スコープを抜けるまでは something は生存が保証される
        }
    }
}
</code></pre>

<p>特に、Android では、Activity への参照を<code class="highlighter-rouge">static</code>な内部クラスで保持するときに用いられる。</p>

<pre><code class="language-Java">public class SomeActivity extends Activity {
    private NestedClass mNestedClass;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // ...

        mNestedClass = new NestedClass(this);
    }

    private static class NestedClass {
        private WeakReference&lt;Activity&gt; mActivity;

        public NestedClass(Activity activity) {
            mActivity = new WeakReference&lt;Activity&gt;(activity);
        }

        public void doWithActivityContext() {
            Activity activity = mActivity.get();
            if (activity == null) {
                return;
            }
            // ...
        }
    }
}
</code></pre>

<h3 id="weakhashmap">WeakHashMap</h3>

<p><code class="highlighter-rouge">HashMap</code>の key の参照が<code class="highlighter-rouge">WeakReference</code>となっており、key が回収された時点で対応する value も削除される。value は強参照で保持されるが、key と value のペアの削除の基準は key の弱参照が回収された時点なので、キャッシュのような使い方には適さない。</p>

<p>使い方は通常の<code class="highlighter-rouge">HashMap</code>と変わらない。注意すべきは、値を取り出すときに既に key が回収されていることを考慮する必要がある点。</p>

<h2 id="section-12">列挙型の活用</h2>

<p>列挙型の特性を活かした各種のデザインパターンの実装がある。</p>

<h3 id="singleton-">Singleton パターン</h3>

<p>列挙型は、列挙したオブジェクトが<code class="highlighter-rouge">public static final</code>な扱いとなるため、そのままでも Singleton パターンをできる。</p>

<pre><code class="language-Java">public enum Hogehoge {
    SINGLETON; // Hogehoge クラスの public static final なフィールドとして扱われる

    public void doSomething() {}
}
</code></pre>

<h3 id="strategy-">Strategy パターン</h3>

<p><code class="highlighter-rouge">abstract</code>なメソッドを作ることが出来るので、以下のような実装をすると Strategy が組める。</p>

<pre><code class="language-Java">public enum Hogehoge {
    TYPE_A {
        @Override
        public void doSomething() {
        }
    },
    TYPE_B {
        @Override
        public void doSomething() {
        }
    };

    public abstract void doSomething();
}
</code></pre>

<p>列挙オブジェクトが増えると煩雑になりがちなので、以下のように戦略を委譲する。</p>

<pre><code class="language-Java">public enum Hogehoge {
    TYPE_A(Strategy.A),
    TYPE_B(Strategy.B); // 戦略が同じであれば、この列挙を増やすだけでよい

    private final Strategy mStrategy;

    private Hogehoge(Strategy strategy) {
        mStrategy = strategy;
    }

    public void doSomething() {
        mStrategy.do();
    }

    private enum Strategy {
        A {
            @Override
            public void do() {
            }
        },
        B {
            @Override
            public void do() {
            }
        };

        public abstract void do();
    }
}
</code></pre>

<h3 id="enum-factory-">Enum Factory パターン</h3>

<p><code class="highlighter-rouge">enum</code>のフィールドに、生成したいクラスのインスタンスを持たせることで、Factory を実現する。</p>

<pre><code class="language-Java">enum Factory {
    HOGE(0, new HogeObject()),
    FUGA(1, new FugaObject());
    // Null Object パターンを実装するならば、UNKNOWN(-1, new UnknownObject());

    private final int mTypeId;
    private final SomeInterface mInstance;

    private Factory(int typeId, SomeInterface instance) {
        mTypeId = typeId;
        mInstance = instance;
    }

    public static Factory valueOf(int typeId) { // Factory の実体を、id から逆引きする
        for (Factory factory : values()) {
            if (factory.getTypeId() == typeId) {
                return factory;
            }
        }
        throw new IllegalArgumentException("unknown type id");
        // あるいは、Null Object パターンに基いた実装をするのも OK
        // return UNKNOWN;
    }

    public static int getTypeCount() {
        return values().length;
    }

    public int getTypeId() {
        return mTypeId;
    }

    public SomeInterface getInstance() {
        return mInstance;
    }
}

interface SomeInterface {
    public void doSomething();
}

class HogeObject implements SomeInterface {
    @Override
    public void doSomething() {}
}

class FugaObject implements SomeInterface {
    @Override
    public void doSomething() {}
}

public class Main {
    public static void main(String[] args) {
        for (int i = 0; i &lt; Factory.getTypeCount(); i++) {
            Factory factory = factory.valueOf(i);
            factory.getInstance().doSomething();
        }
    }
}
</code></pre>

<p>インスタンスではなく、型トークンを持たせることで、DI フレームワークによる On-Demand-Injection が可能。</p>

<pre><code class="language-Java">enum Factory {
    HOGE(0, HogeObject.class),
    FUGA(1, FugaObject.class);
    // Null Object パターンを実装するならば、UNKNOWN(-1, UnknownObject.class);

    private final int mTypeId;
    private final Class&lt;? extends SomeInterface&gt; mClass;

    private Factory(int typeId, Class&lt;? extends SomeInterface&gt; clazz) {
        mTypeId = typeId;
        mClass = clazz;
    }

    public static Factory valueOf(int typeId) { // Factory の実体を、id から逆引きする
        for (Factory factory : values()) {
            if (factory.getTypeId() == typeId) {
                return factory;
            }
        }
        throw new IllegalArgumentException("unknown type id");
        // あるいは、Null Object パターンに基いた実装をするのも OK
        // return UNKNOWN;
    }

    public static int getTypeCount() {
        return values().length;
    }

    public int getTypeId() {
        return mTypeId;
    }

    public SomeInterface getInstance(Context context) {
        return RoboGuice.getInjector(context).getInstance(mClass);
        // return Proton.getInjector(context).getInstance(mClass);
    }
}
</code></pre>

<h3 id="section-13">列挙型とコレクションフレームワーク</h3>

<p>列挙型で列挙したオブジェクトをコレクションの中で取り扱う場合は、通常のコレクションクラスではなく、専用のコレクションクラスを使う。</p>

<p><code class="highlighter-rouge">Set</code>には<code class="highlighter-rouge">EnumSet</code>、<code class="highlighter-rouge">Map</code>には<code class="highlighter-rouge">EnumMap</code>があり、それぞれ enum 専用にパフォーマンスのチューニングが施されている。</p>

<pre><code class="language-Java">enum Hoge {
    FOO,BAR,BAZ,QUX,QUUX;
}

public class Main {
    public static void main(String[] args) {
        // enum が含まれる Set の生成
        Set&lt;Hoge&gt; part = EnumSet.of(Hoge.FOO, Hoge.BAR); // (FOO | BAR)
        Set&lt;Hoge&gt; all = EnumSet.allOf(Hoge.class); // (FOO | BAR | BAZ | QUX | QUUX)
        Set&lt;Hoge&gt; empty = EnumSet.noneOf(Hoge.class); // ()
        Set&lt;Hoge&gt; copy = EnumSet.copyOf(part); // (FOO | BAR)
        Set&lt;Hoge&gt; complement = EnumSet.complementOf(part); // (BAZ | QUX | QUUX)
        Set&lt;Hoge&gt; range = EnumSet.range(Hoge.BAR, Hoge.QUX); // (BAR | BAZ | QUX), 引数の順序を逆にすると IllegalArgumentException

        // enum を key とする Map の生成
        Map&lt;Hoge, Object&gt; map = new EnumMap(Hoge.class);
        for (Hoge hoge : Hoge.values()) {
            map.put(hoge, hoge.name());
        }
    }
}
</code></pre>

<h3 id="section-14">列挙型とパフォーマンス</h3>

<p>列挙型は非常に便利なしくみであり、他の言語に見られる単純な数値の列挙とは異なり振る舞いを持つことが出来る点が大きな利点である。</p>

<p>一方で、列挙型は、以下の様なパフォーマンス上の欠点もある。</p>

<ul>
  <li>列挙したオブジェクトの数だけ中間ファイルが生成されるため、列挙が増えるほどアプリケーションの容量が膨れ上がる</li>
  <li>列挙型のクラスがロードされるタイミングですべての列挙したオブジェクトの初期化処理が実行されるため、列挙が多いほど、クラスの初期化に時間がかかるようになる</li>
  <li>列挙したオブジェクトの数だけメモリを食い続ける</li>
  <li>int 型などの定数と異なり、コンパイラによるインライン化の恩恵が受けられない</li>
</ul>

<p>単純な<code class="highlighter-rouge">int</code>型定数の列挙の置き換えとして用いると、コストパフォーマンスが悪くなるため、Android のような少メモリ環境では敢えて使用を控える傾向がある。</p>

<h2 id="section-15">アノテーション</h2>

<h3 id="section-16">標準アノテーションの使用</h3>

<p>Java の標準 API で手供されているアノテーションを用いて、コンパイル時にエラー・警告のチェックが可能となる。</p>

<h4 id="override">@Override</h4>

<p>アノテーションの付いたメソッドが、親クラスからの継承か、インタフェースの実装であることを示す。</p>

<p>これにより、誤った実装によるオーバーロードとの間違いや、実装の不足等がコンパイル時に検出され、コンパイルエラーとして扱われるようになる。</p>

<h4 id="suppresswarnings">@SuppressWarnings</h4>

<p>警告の抑制のためのアノテーション。プログラマが、当該の警告は無視できると判断した場合に使用する。</p>

<h4 id="deprecated">@Deprecated</h4>

<p>アノテーションを付与したクラスまたはメソッド、コンストラクタが、古い実装や設計に基づいており、今後のリリースでは使用すべきでないことを、API の利用者に警告するためのアノテーション。新しい API の導入に伴って、下位互換を保つため古い API を残す必要がある時、新しい API の使用を促すために用いられる。</p>

<h3 id="section-17">その他のアノテーションの使用</h3>

<p>Java の標準 API 以外で手供されているアノテーションを紹介する。</p>

<h4 id="nullable">@Nullable</h4>

<p>JSR-305 にて標準化が進められているアノテーション。</p>

<p>引数が<code class="highlighter-rouge">null</code>を許容する(<code class="highlighter-rouge">null</code>が来ても問題なく動作するよう設計されている)ことを示す、あるいは、返り値として<code class="highlighter-rouge">null</code>を返すことがある事を示す。</p>

<h4 id="notnull">@NotNull</h4>

<p>JSR-305 にて標準化が進められているアノテーション。</p>

<p>引数が<code class="highlighter-rouge">null</code>を許容せず、もし引数に<code class="highlighter-rouge">null</code>をセットした場合は警告する、あるいは、返り値が<code class="highlighter-rouge">null</code>でないことを保証する事を示す。</p>

<h4 id="inject">@Inject</h4>

<p>JSR-330 にて標準化されたアノテーション。</p>

<p>DI のためのアノテーションで、このアノテーションが付与されたフィールドに対し、インスタンスのインジェクションが行われることを示す。</p>

<h4 id="test">@Test</h4>

<p>JUnit4 で使用されるアノテーション。</p>

<p>アノテーションを付与したメソッドがテストケースメソッドであることを示す。</p>

<h4 id="ignore">@Ignore</h4>

<p>JUnit4 で使用されるアノテーション。</p>

<p>アノテーションを付与したメソッドをテストでは無視することを示す。</p>

<h4 id="runwith">@RunWith</h4>

<p>JUnit4 で使用されるアノテーション。</p>

<p>テストクラスが、指定のテストランナーで実行されることを示す。</p>

<h4 id="before">@Before</h4>

<p>JUnit4 で使用されるアノテーション。</p>

<p>テストケース実行前に必ず実行される、テストケースのセットアップメソッドであることを示す。</p>

<h4 id="after">@After</h4>

<p>JUnit4 で使用されるアノテーション。</p>

<p>テストケース実行後に必ず実行される、テストケースの事後処理メソッドであることを示す。</p>

<h2 id="section-18">例外</h2>

<h3 id="section-19">標準実行時例外の使用</h3>

<p>Java の標準 API で提供されている実行時例外を使用することで、API における例外の標準化ができる。</p>

<h4 id="arithmeticexception">ArithmeticException</h4>

<p>ゼロ除算など、算術計算処理中の例外的状況を示すために使われる。</p>

<h4 id="arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</h4>

<p>配列のサイズを超えた index を用いて配列にアクセスしようとした場合にスローされる。</p>

<h4 id="classcastexception">ClassCastException</h4>

<p>明示的キャストが失敗した場合（継承関係にないサブクラスへのキャスト）にスローされる。</p>

<h4 id="illegalargumentexception">IllegalArgumentException</h4>

<p>引数に誤りがあることを示す例外。</p>

<h4 id="illegalstateexception">IllegalStateException</h4>

<p>オブジェクトの状態が不正であることを示す例外。
メソッドの実行時、オブジェクトが持つフィールドが不正な値である場合にスローされる。</p>

<h4 id="nullpointerexception">NullPointerException</h4>

<p><code class="highlighter-rouge">null</code>値に対する操作を示す例外。</p>

<h4 id="numberformatexception">NumberFormatException</h4>

<p>文字列が、数字への変換が不可能なフォーマットであるにもかかわらず、数字への変換が行われることを示す例外。</p>

<h4 id="stringindexoutofboundsexception">StringIndexOutOfBoundsException</h4>

<p>文字列の長さを超えた index を使用した文字列へのアクセスを示す例外。</p>

<h4 id="unsupportedoperationexception">UnsupportedOperationException</h4>

<p>メソッドが未実装であることを示す例外。</p>

<h3 id="section-20">例外のラップ</h3>

<p>例外は、クラス設計上のレイヤごとに適切な例外をスローすべきで、不用意に低レイヤな例外を上位レイヤへスローすべきでない。</p>

<p>以下のように、例外をラップして、再度スローするように実装する。</p>

<pre><code class="language-Java">try {
    // IO に関する何らかの処理
} catch (IOException e) {
    // フォールバック処理
    throw new FileCreationException(e); // キャッチした例外を、新しくスローする例外へ引き渡す
}
</code></pre>

<p>キャッチした例外は、新しくスローする例外に引き渡すようにする。これにより、例外のスタックトレースに、原因となった例外が出力されるため、デバッグに使用するに足る情報が与えられる。</p>

<h3 id="section-21">エラーアトミック性</h3>

<p>メソッドの呼び出し中に何らかのエラー・例外によって、その処理が失敗した場合、オブジェクトの状態を、失敗する前の状態へ戻すことを保証すること。データベースの操作におけるトランザクションの原子性と同じような考え方に基づき、耐障害性を保証する。</p>

<p>このような、エラーアトミック性を支援する目的で、検査例外を用いる事がある。検査例外は、例外の発生条件を事前に定義することができないが、キャッチした際には、その例外から有用な情報を用いて適切に復帰処理を行わせる目的で使用される。検査例外のキャッチの中で、適切にエラーアトミック性を保つための処理を記述する。</p>

<pre><code class="language-Java">try {
    // 新規のファイルに何らかのデータを書き出す処理
} catch (IOException e) {
    // ファイルの書き出し中のエラーだったら、作成途中のファイルを消す等のフォールバック - エラーアトミックになるように！
    throw new FileCreationException(e); // フォールバックが終わったら例外を再度スロー
}
</code></pre>

<h2 id="new-io">New I/O</h2>

<h3 id="section-22">バッファ</h3>

<p><code class="highlighter-rouge">boolean</code>以外のプリミティブ型データを保持するための仕組み。<br />
<code class="highlighter-rouge">int</code>に対応するバッファクラスのクラス名に注意する。</p>

<table>
  <thead>
    <tr>
      <th>クラス名</th>
      <th>対応する型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">ByteBuffer</code></td>
      <td><code class="highlighter-rouge">byte</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CharBuffer</code></td>
      <td><code class="highlighter-rouge">char</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ShortBuffer</code></td>
      <td><code class="highlighter-rouge">short</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">IntBuffer</code></td>
      <td><code class="highlighter-rouge">int</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">LongBuffer</code></td>
      <td><code class="highlighter-rouge">long</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FloatBuffer</code></td>
      <td><code class="highlighter-rouge">float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">DoubleBuffer</code></td>
      <td><code class="highlighter-rouge">double</code></td>
    </tr>
  </tbody>
</table>

<h3 id="section-23">チャネル</h3>

<h2 id="new-io2">New I/O2</h2>

<h3 id="section-24">非同期チャネル</h3>

          </section>
        </div>

        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
          <footer class="inner">
  <p class="license">Portions of this page are reproduced from work created and <a href="https://code.google.com/p/android/">shared by the Android Open Source Project</a> and used according to terms described in the <a href="http://creativecommons.org/licenses/by/2.5/">Creative Commons2.5 Attribution License</a>.</p>
  <p class="license">
  This work is licensed under a <a rel="license" itemprop="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. 
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
  </p>
  <p class="copyright">Androidtraining maintained by <a href="https://github.com/mixi-inc" itemprop="author">mixi-inc</a></p>
  <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>

</footer>

        </div>
      </paper-scroll-header-panel>
    </paper-drawer-panel>
    <script>
        // custom transformation: scale header's title
        var title = document.querySelectorAll('.title')[2];
        addEventListener('paper-header-transform', function(e) {
            var d = e.detail;
            var m = d.height - d.condensedHeight;
            var scale = Math.max(0.75, (m - d.y) / (m / 0.25)  + 0.75);

            Polymer.Base.transform('scale(' + scale + ') translateZ(0)', title);
        });

    </script>
</body>
</html>
