<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="この章では、Android での非同期処理について解説します。" />
    <meta name=viewport content="width=device-width, initial-scale=1">
    <!-- ogp for twitter -->
    <meta content="@mixi_engineers" name="twitter:site" />
    <meta content="summary" name="twitter:card" />
    
    <meta content="非同期処理 - mixi-inc/AndroidTraining" name="twitter:title" />
    
    <meta content="この章では、Android での非同期処理について解説します。" name="twitter:description" />
    <meta content="/assets/logo.png" name="twitter:image:src" />
    <!-- ogp -->
    <meta content="mixi-inc/AndroidTraining" property="og:site_name" />
    <meta content="article" property="og:type" />
    <meta content="/assets/logo.png" property="og:image" />
    
    <meta content="非同期処理 - mixi-inc/AndroidTraining" name="og:title" />
    
    <meta content="/fundamentals/2.08.async-processing.html" property="og:url" />
    <meta content="この章では、Android での非同期処理について解説します。" property="og:description" />
    
    <meta name="keyword" content="android, training, 基礎, スキル, 開発, developer, プログラミング, Service, 非同期, Loader" />
    

    <meta name="go-import" content="github.com/mixi-inc/AndroidTraining git https://github.com/mixi-inc/AndroidTraining.git">
    <script src="/AndroidTraining/bower_components/webcomponentsjs/webcomponents.js"></script>
    
    <link rel="stylesheet" type="text/css" media="screen" href="/AndroidTraining/stylesheets/main.css">
    <link rel="shortcut icon" href="/AndroidTraining/assets/favicon.ico" />
    <link rel="import" href="/AndroidTraining/bower_components/paper-scroll-header-panel/paper-scroll-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-drawer-panel/paper-drawer-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-header-panel/paper-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-toolbar/paper-toolbar.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-menu/paper-menu.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-item/paper-item.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-icon-button/paper-icon-button.html">
    <link rel="import" href="/AndroidTraining/bower_components/iron-icons/iron-icons.html">
    <style is="custom-style">
        paper-scroll-header-panel:not([style-scope]):not(.style-scope) {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        paper-toolbar.tall .bottom:not([style-scope]):not(.style-scope) {
            font-size: 40px;
            margin-left: 60px;

            -webkit-transform-origin: left center;
            transform-origin: left center;
        }

        .content:not([style-scope]):not(.style-scope) {
            padding: 8px;
        }

        .spacer:not([style-scope]):not(.style-scope) {
            -ms-flex: 1 1 0.000000001px;
            -webkit-flex: 1;
            flex: 1;
            -webkit-flex-basis: 0.000000001px;
            flex-basis: 0.000000001px;
        }

    </style>
    <title>非同期処理 - mixi-inc/AndroidTraining</title>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-50931519-13', 'auto');
    ga('send', 'pageview');
    </script>
  </head>

  <body itemscope itemtype="http://schema.org/Article" fullbleed layout vertical>

    <paper-drawer-panel selected="main" >
      <!-- MENU -->
      <paper-header-panel mode="seamed" drawer class="drawer">
        <nav>
    <ol class="chapter_navigation">
        <a href="/AndroidTraining/">Home</a>
        <li>まえがき</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/introductions/1.01.about-android-os.html">Android-OSについて</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.02.prepare-for-development.html">開発環境の準備</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.03.create-project-for-android-studio.html">プロジェクトの作成</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.04.basic-knowledge.html">Androidの基礎知識</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.05.how-to-build-for-gradle.html">Android のビルドについて(Gradle)</a></li>
            
        </ol>
        <li>基礎編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/fundamentals/2.01.create-layout.html">アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.02.activity-and-fragment.html">ActivityとFragment</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.03.application-resource-management.html">アプリのリソース管理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.04.messaging-and-notification.html">メッセージングと通知</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.05.actionbar-and-interaction-control.html">AppBarとインタラクション制御</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.06.listView-and-viewPager.html">ListViewとViewPager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.07.serialize-and-collection-and-perpetuation.html">直列化とコレクション、永続化</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.08.async-processing.html">非同期処理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.09.network-access.html">ネットワーク通信</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.10.database.html">データベース</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing-for-android-studio.html">テスト(AndroidStudio)</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing.html">テスト</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.12.handler-and-looper.html">HandlerとLooper</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.13.webView.html">WebView</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.14.accountmanager.html">AccountManager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.15.advance-contentprovider.html">ContentProviderの発展</a></li>
            
        </ol>
        <li>実務編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-eclipse.html">デバッグと自動ビルド(Eclipse)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-gradle.html">自動ビルド(Android Studio)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.02.architecture-and-di.html">アーキテクチャ設計と DI</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.03.advanced-layout.html">続・アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.04.user-interface.html">ユーザインタフェース設計</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.05.security.html">セキュリティ</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.06.google-api.html">Google API</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.07.google-play-services.html">Google Play Services</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.08.cloud-sync.html">クラウド同期</a></li>
            
        </ol>
        <li>デザイナー編</li>
        <ol>
        </ol>
    </ol>
    <ol class="appex_navigation">
        <li>付録</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/appendix/A.01.import-from-git-for-eclipse.html">Git リポジトリからのプロジェクトのインポート</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.02.basic-java.html">Java の文法の基礎</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.03.how-to-create-avd.html">仮想デバイスの作成</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.04.advanced-java.html">Javaの活用</a></li>
            
        </ol>
    </ol>
</nav>

      </paper-header-panel>
      <paper-scroll-header-panel main condenses>
        <!-- HEADER -->
        <paper-toolbar class="mainheader tall" role="toolbar">
    <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>

    <span class="title"></span>

    <a id="forkme_banner" href="https://github.com/mixi-inc/AndroidTraining" role="button">
        <paper-icon-button src="/AndroidTraining/images/blacktocat.png"></paper-icon-button> <span>View on GitHub</span>
    </a>

    <div class="middle title">mixi-inc/AndroidTraining</div>
    <div class="bottom title">非同期処理</div>
</paper-toolbar>


<div id="description" itemprop="description">この章では、Android での非同期処理について解説します。</div>



        <!-- MAIN CONTENT -->
        <div id="main_content_wrap" class="content outer" itemprop="articleBody">
          <section id="main_content" class="inner">
            <p>参考：<a href="http://developer.android.com/guide/components/services.html">Services | Android Developers</a><br />
参考：<a href="http://developer.android.com/guide/components/loaders.html">Loaders | Android Developers</a><br />
参考：<a href="http://developer.android.com/guide/components/processes-and-threads.html">Processes and Threads | Android Developers</a></p>

<h2 id="section">目次</h2>

<ul>
  <li><a href="#Service">Service</a>
    <ul>
      <li><a href="#Service の状態">Service の状態</a></li>
      <li><a href="#Service のライフサイクル">Service のライフサイクル</a></li>
      <li><a href="#Service を構築するクラス">Service を構築するクラス</a></li>
      <li><a href="#Service の呼び出し">Service の呼び出し</a></li>
    </ul>
  </li>
  <li><a href="#Loader">Loader</a>
    <ul>
      <li><a href="#AsyncTaskLoader">AsyncTaskLoader</a></li>
      <li><a href="#CursorLoader">CursorLoader</a></li>
    </ul>
  </li>
  <li><a href="#AsyncTask">AsyncTask</a></li>
</ul>

<h2 id="service">Service</h2>

<p>Service とは、バックグラウンドで動作する Android のコンポーネントです。</p>

<h3 id="service-">Service の状態</h3>

<p><code class="highlighter-rouge">Service</code>は、その呼び出し方によって 2 つのいずれかの状態をとります。</p>

<h4 id="section-1">開始</h4>

<p><code class="highlighter-rouge">Context#startService(Intent)</code>によって呼び出された時の状態です。<br />
<code class="highlighter-rouge">Context#startService(Intent)</code>を呼び出したコンポーネントとは別のライフサイクルを持つので、そのコンポーネントが死んでも生きていることがあります。<br />
通常、この呼出で呼び出された<code class="highlighter-rouge">Service</code>は、結果を呼び出し元に返すことはありません。<code class="highlighter-rouge">Service</code>の処理内容が終わったら、自身で<code class="highlighter-rouge">Service</code>のライフサイクルを終わらせる必要があります。</p>

<h4 id="section-2">バインド</h4>

<p><code class="highlighter-rouge">Context#bindService(Intent)</code>によって呼び出された時の状態です。<br />
<code class="highlighter-rouge">Service</code>をバインドすることによって、呼び出し元のコンポーネントと<code class="highlighter-rouge">Service</code>の間に、クライアント-サーバの関係が構築されます。<br />
よって、バインドされた<code class="highlighter-rouge">Service</code>と連携したり、リクエストを送ったり、結果を取得したり、プロセス間通信をも行うことが可能となります。<br />
バインドされた<code class="highlighter-rouge">Service</code>のライフサイクルは、バインドしたコンポーネントのライフサイクルに合わせられます。<br />
複数のコンポーネントが<code class="highlighter-rouge">Service</code>をバインドすることも可能ですので、全てのバインドしたコンポーネントが破棄された時に、<code class="highlighter-rouge">Service</code>のライフサイクルも終了します。</p>

<h3 id="service--1">Service のライフサイクル</h3>

<p><code class="highlighter-rouge">Service</code>がどのように呼び出されたかによって、ライフサイクルが異なります。</p>

<p><img src="/AndroidTraining/assets/02-08/service_lifecycle.png" alt="Service Lifecycle" /></p>

<p><code class="highlighter-rouge">Context#startService(Intent)</code>によって開始された<code class="highlighter-rouge">Serivce</code>は、自身が終了を宣言するか、誰かが終了を命令するまで生存し続けます。</p>

<p><code class="highlighter-rouge">Context#bindService(Intent)</code>によってバインドされた<code class="highlighter-rouge">Service</code>は、バインドしている呼び出し元が全員バインドの解除を行うまで生存し続けます。</p>

<h3 id="service--2">Service を構築するクラス</h3>

<h4 id="service-1">Service</h4>

<p>一般的な Service を作成するひな形クラスです。<br />
バックグラウンドで動作するものではありますが、その実動作しているスレッドは、Service を動かしているプロセスのメインスレッドです。<br />
つまり、Service 内でブロックする処理を記述すると、メインスレッドの処理がブロックします。よって、独自のプロセスで動かしたい場合は、その旨 AndroidManifest で宣言する必要があり、また、ブロックする処理を実行する場合は、自分でスレッドを新しく立てる必要があります。</p>

<p>また、サービスの状態（開始、またはバインド）によって、プログラムの書き方に若干の違いがあることに注意してください。</p>

<p>下記に、その例を示します。</p>

<pre><code class="language-Java">/**
 * Service を継承したクラス。
 * {@link Context#startService(Intent)}で呼び出すためのサンプル。
 */
public class StartedService extends Service {
    public static final String TAG = StartedService.class.getSimpleName();

    /**
     * {@link Service} のライフサイクルの開始。
     */
    @Override
    public void onCreate() {
        super.onCreate();
        Log.v(TAG, "onCreate");
    }

    // バインド用のメソッド。今回は特に必要ないので null を返す。
    @Override
    public IBinder onBind(Intent intent) {
        Log.v(TAG, "onBind");
        return null;
    }

    /**
     * {@link Context#startService(Intent)} の呼び出しで呼ばれる。
     * このメソッドの処理は、{@link Context#startService(Intent)}を呼び出したスレッドと同じスレッドで実行されるので
     * メインスレッドで {@link Service} を起動した場合に、ここでネットワーク通信などスレッドをブロックする処理をしてしまうと
     * UI の処理がブロックされ AND となる。
     */
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.v(TAG, "onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }

    /**
     * {@link Service} のライフサイクルの終了。
     */
    @Override
    public void onDestroy() {
        Log.v(TAG, "onDestroy");
        super.onDestroy();
    }
}
</code></pre>

<pre><code class="language-Java">/**
 * バインドするサービス。
 */
public class BoundService extends Service {
    public static final String TAG = BoundService.class.getSimpleName();
    private final IBinder mBinder = new ServiceBinder();

    @Override
    public void onCreate() {
        super.onCreate();
        Log.v(TAG, "onCreate");
    }

    // 最初にバインドした時のコールバック
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    // 再度バインドした時のコールバック
    @Override
    public void onRebind(Intent intent) {
        super.onRebind(intent);
        Log.v(TAG, "onRebind");
    }

    // バインドを解除された時のコールバック
    @Override
    public boolean onUnbind(Intent intent) {
        Log.v(TAG, "onUnbind");
        return super.onUnbind(intent);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.v(TAG, "onDestroy");
    }

    // サービスをバインドした後、バインドしたサービスのインスタンスそのものを得るためのインタフェース
    public class ServiceBinder extends Binder {
        public BoundService getService() {
            return BoundService.this;
        }
    }
}
</code></pre>

<p>開始するサービスも、バインドするサービスも、AndroidManifest には以下のように記述します。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code>    <span class="nt">&lt;application</span>
        <span class="na">android:allowBackup=</span><span class="s">"true"</span>
        <span class="na">android:icon=</span><span class="s">"@drawable/ic_launcher"</span>
        <span class="na">android:label=</span><span class="s">"@string/app_name"</span>
        <span class="na">android:theme=</span><span class="s">"@style/AppTheme"</span> <span class="nt">&gt;</span>
        <span class="nt">&lt;service</span>
            <span class="na">android:name=</span><span class="s">"jp.mixi.sample.service.BoundService"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;service</span>
            <span class="na">android:name=</span><span class="s">"jp.mixi.sample.service.StartedService"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/application&gt;</span>
</code></pre>
</div>

<h4 id="intentservice">IntentService</h4>

<p>Intent による呼び出しで開始される Service であり、かつ、Service の開始要求を 1 つずつ順に処理するワーカスレッド上で動作する特別な Service です。
一度に複数の処理を並列して行う必要がない場合は、IntentService を利用するほうが実装が簡単です。</p>

<pre><code class="language-Java">public class MyIntentService extends IntentService {
    public static final String TAG = MyIntentService.class.getSimpleName();

    public MyIntentService() {
        this(MyIntentService.class.getSimpleName());
    }

    public MyIntentService(String name) {
        super(name);
    }

    /**
     * {@link Service} のライフサイクルの開始。
     */
    @Override
    public void onCreate() {
        super.onCreate();
        Log.v(TAG, "onCreate");
    }

    /**
     * 親クラスで必要な処理がひと通り揃っているため、通常は Override の必要はない。
     */
    @Override
    public IBinder onBind(Intent intent) {
        Log.v(TAG, "onBind");
        return super.onBind(intent);
    }

    /**
     * 親クラスで必要な処理がひと通り揃っているため、通常は Override の必要はない。
     */
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.v(TAG, "onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }

    /**
     * {@link Context#startService(Intent)} によって呼び出される。
     * ワーカスレッド上で実行されるため、ネットワーク通信等のスレッドをブロックする処理を直接記述しても問題ない。
     */
    @Override
    protected void onHandleIntent(Intent intent) {
        Log.v(TAG, "onHandleIntent");
    }

    /**
     * {@link Service} のライフサイクルの終了。
     * {@link IntentService} では、1 回の {@link Context#startService(Intent)} の呼び出しで
     * 1 つのライフサイクルが回るように作られている。
     */
    @Override
    public void onDestroy() {
        Log.v(TAG, "onDestroy");
        super.onDestroy();
    }
}
</code></pre>

<p>こちらも、AndroidMafifest には、<code class="highlighter-rouge">Service</code>と同じ宣言を行います。</p>

<h3 id="service--3">Service の呼び出し</h3>

<p>開始するサービスと、<code class="highlighter-rouge">IntentService</code>は、以下のように呼び出します。<br />
開始するサービスは、サービス自身で終了の命令を実行しない場合、サービスを止めるメソッドを呼び出します(<code class="highlighter-rouge">IntentService</code>は自分で終了するため必要ありません)。</p>

<pre><code class="language-Java">public class MyActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // do something ...

        Intent intent = new Intent(this, StartedService.class);
        startService(intent);
    }

    @Override
    protected void onStop() {
        Intent intent = new Intent(this, StartedService.class);
        stopService(intent);
        super.onStop();
    }
}
</code></pre>

<p>バインドするサービスは、以下のように呼び出します。<br />
呼び出した後、バインドしたサービスのインスタンスを受け取って、直接そのインスタンスを操作する事ができるようになります。<br />
バインドするサービスは、バインドするコンポーネントのライフサイクルにしたがって管理する必要があるので、コンポーネントのライフサイクルの終わりにサービスのバインドを解除する必要があります。</p>

<pre><code class="language-Java">public class MyActivity extends Activity {
    private BoundService mBoundService;
    // BoundService を扱う時のインタフェース
    private ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceDisconnected(ComponentName name) {
            Log.v(TAG, "onServiceDisconnected");
            mBoundService = null;
        }

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            Log.v(TAG, "onServiceConnected");
            mBoundService = ((BoundService.ServiceBinder) service).getService();
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // do something ...

        // サービスのバインド
        // バインド時の、バインド元とバインド先サービスの橋渡しをするための ServiceConnection インスタンスを一緒に渡す
        // Context.BIND_AUTO_CREATE によって、バインド時に自動で Service のライフサイクルが始まるようになる
        bindService(new Intent(MainActivity.this, BoundService.class), mConnection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        unbindService(mConnection);
        super.onStop();
    }
}
</code></pre>

<h2 id="loader">Loader</h2>

<p>非同期に処理を行うための新しいフレームワークです。特に、ネットワークやファイル I/O を介してデータを読み出すためのフレームワークとして設計されているものです。<br />
Activity や Fragment のライフサイクルと、非同期処理を分離する目的で作られており、後述する<code class="highlighter-rouge">AsyncTask</code>の改良版とも言えます。</p>

<p><code class="highlighter-rouge">Loader</code>は Honeycomb 以後から導入されました。<br />
SupportPackage にも含まれているので、2.x 系の OS でも利用することができます。</p>

<h3 id="asynctaskloader">AsyncTaskLoader</h3>

<p>ネットワーク通信やその他のファイル I/O などによってデータを読み出す場合は、このクラスを拡張して非同期処理を記述します。</p>

<pre><code class="language-Java">// Support Package のものを利用する
import android.support.v4.content.AsyncTaskLoader;

public class MyAsyncTaskLoader extends AsyncTaskLoader&lt;String&gt; {
    public static final String TAG = MyAsyncTaskLoader.class.getSimpleName();
    private String mCachedData;

    public MyAsyncTaskLoader(Context context) {
        super(context);
    }

    // 非同期処理の中身
    @Override
    public String loadInBackground() {
        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            Log.e(TAG, "interrupted!: ", e);
        }
        return "hogehoge";
    }

    @Override
    public void deliverResult(String data) {
        // ローダがリセットされ、そのローダのライフサイクルが終了となる場合
        if (isReset()) {
            // キャッシュデータがある場合は、キャッシュを削除して、メモリから破棄可能にする
            if (mCachedData != null) {
                mCachedData = null;
            }
            return;
        }

        // 得られたデータをキャッシュする
        mCachedData = data;

        // ローダが開始されている場合、親にデータが得られたことを通知する
        if (isStarted()) {
            super.deliverResult(data);
        }
    }

    @Override
    protected void onStartLoading() {
        // キャッシュがある場合はそちらを返す
        if (mCachedData != null) {
            deliverResult(mCachedData);
            return;
        }

        // データソースに変更があったり、キャッシュデータがない場合は loadInBackground() に行くようにする
        if (takeContentChanged() || mCachedData == null) {
            forceLoad();
        }
    }

    // ローダの非同期処理がストップする時のコールバック
    @Override
    protected void onStopLoading() {
        cancelLoad();
        super.onStopLoading();
    }

    // ローダがリセットされる時のコールバック
    @Override
    protected void onReset() {
        onStopLoading();
        super.onReset();
    }
}
</code></pre>

<h3 id="loader-">Loader の呼び出しとコールバック</h3>

<p>ローダとのやりとりは、<code class="highlighter-rouge">LoaderManager</code>と<code class="highlighter-rouge">LoaderCallbacks</code>を用いて行います。</p>

<pre><code class="language-Java">public class MainActivity extends FragmentActivity implements LoaderCallbacks&lt;String&gt; {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // ローダの管理をするオブジェクト
        LoaderManager manager = getSupportLoaderManager();
        Bundle argsForLoader = new Bundle();
        // ローダを初期化して非同期処理を開始する
        manager.initLoader(0, argsForLoader, MainActivity.this);
    }

    // id に対応した Loader のインスタンスを作って返す
    // args は Loader に渡したい引数を Bundle に詰めたもの
    @Override
    public Loader&lt;String&gt; onCreateLoader(int id, Bundle args) {
        switch (id) {
            case 0:
                return new MyAsyncTaskLoader(this);
            default:
                return null;
        }
    }

    // 結果を受け取るコールバック
    // メインスレッドで動作する
    @Override
    public void onLoadFinished(Loader&lt;String&gt; loader, String result) {
        Toast.makeText(this, result, Toast.LENGTH_LONG).show();
    }

    // ローダがリセットされる時のコールバック
    @Override
    public void onLoaderReset(Loader&lt;String&gt; loader) {}
}
</code></pre>

<h3 id="cursorloader">CursorLoader</h3>

<p>別の章で解説する、データベースからのデータの読み出しに特化したクラスです。</p>

<h2 id="asynctask">AsyncTask</h2>

<p>名前の通り、非同期処理のためのクラスです。<br />
非同期に実行したい処理と、処理前、処理後のメインスレッド上での処理を記述するため、このクラスを継承して使います。</p>

<p><code class="highlighter-rouge">AsyncTask</code>では、内部でスレッドプールを持っています(Donut までは単一のスレッドで動作していた)。<br />
デフォルトでは 5 つのスレッドがプールされており、内部で並列して複数の非同期処理を実行できるようになっています(Honeycomb 以降は、スレッドの並列実行における諸問題を回避するため単一スレッドで動作するように戻っている)。<br />
最大でプールされるスレッド数は 128 です。</p>

<p><code class="highlighter-rouge">AsyncTask</code>オブジェクトは、使い回しができません。一度処理が完了すると、その後にもう一度非同期処理の実行を依頼した時点で、例外が投げられます。<br />
よって、再度非同期処理を実行したい場合は、新たに<code class="highlighter-rouge">AsyncTask</code>オブジェクトを作成する必要があります。</p>

<pre><code class="language-Java">/**
 * 非同期処理を実行するためのネストクラス。
 *
 * ジェネリクスの仕組みを用いて、非同期処理に渡す引数の型、進捗を監視するコールバック用の型、非同期処理の結果を表す型を指定する。
 *
 * Activity や Fragment のライフサイクルに合わせて、自分で AsyncTask をコントロールする必要があり、これを行わないと
 * 特に {@link AsyncTask#onPostExecute()} で、参照するオブジェクトが既にメモリから破棄されていて NullPointerException となることが起こりえる。
 */
public class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; {
    private Context mApplicationContext;

    public MyAsyncTask(Context applicationContext) {
        super();
        mApplicationContext = applicationContext;
    }

    /**
     * 非同期処理を実行する前に UI スレッドで実行する処理を書く
     */
    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        Toast.makeText(mContext, "onPreExecute", Toast.LENGTH_SHORT).show();
    }

    /**
     * 非同期処理の進捗を受け取るコールバック。
     */
    @Override
    protected void onProgressUpdate(Void... values) {
        super.onProgressUpdate(values);
        Toast.makeText(mContext, "onProgressUpdate", Toast.LENGTH_SHORT).show();
    }

    /**
     * 非同期処理の本体
     * 引数は非同期処理内容に渡すためのパラメータ配列。
     */
    @Override
    protected Void doInBackground(Void... params) {
        // 2 秒おきに進捗を通知する
        try {
            publishProgress();
            Thread.sleep(2000L);
            publishProgress();
            Thread.sleep(2000L);
            publishProgress();
            Thread.sleep(2000L);
            publishProgress();
            Thread.sleep(2000L);
            publishProgress();
            Thread.sleep(2000L);
            publishProgress();
        } catch (InterruptedException e) {
            Log.e(MyAsyncTask.class.getSimpleName(), "thread interrupted: ", e);
        }
        return null;
    }

    /**
     * 非同期処理の実行後に、UI スレッドで実行する処理。
     * 引数は {@link AsyncTask#execute(Object...)} の返り値。
     */
    @Override
    protected void onPostExecute(Void result) {
        super.onPostExecute(result);
        Toast.makeText(mContext, "onPostExecute", Toast.LENGTH_SHORT).show();
    }
}
</code></pre>

<pre><code class="language-Java">public class MyActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // do something...

        // 非同期処理の開始
        new MyAsyncTask(getApplicationContext()).execute();
    }
}
</code></pre>

<h2 id="section-3">実習・課題</h2>

<h3 id="service-2">Service</h3>

<ol>
  <li>(実習) サンプルプロジェクト (ServiceSample) に、サービスのライフサイクルをログに出力する実装が格納されています。このプロジェクトをビルドし、ログがどのように出力されているかをレポートしてください。</li>
  <li>(課題) SharedPreferences にデータを書き込むための IntentService を作成してください。</li>
</ol>

<h3 id="loader-1">Loader</h3>

<ol>
  <li>(実習) サンプルプロジェクト (LoaderSample) に、AsyncTaskLoader のライフサイクルをログに出力する実装が格納されています。このプロジェクトをビルドし、ログがどのように出力されているかをレポートしてください。</li>
  <li>(課題) SharedPreferences からデータを読み出すための AsyncTaskLoader を作成してください（プロジェクトは Service の課題と同じ物を用いること）。</li>
</ol>

<h3 id="asynctask-1">AsyncTask</h3>

<ol>
  <li>(実習) <code class="highlighter-rouge">AsyncTask#doInBackground()</code> で、TextView の文字を変更するような、UI の処理を実行するとどうなるか、理由を添えてレポートしてください。</li>
</ol>

          </section>
        </div>

        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
          <footer class="inner">
  <p class="license">Portions of this page are reproduced from work created and <a href="https://code.google.com/p/android/">shared by the Android Open Source Project</a> and used according to terms described in the <a href="http://creativecommons.org/licenses/by/2.5/">Creative Commons2.5 Attribution License</a>.</p>
  <p class="license">
  This work is licensed under a <a rel="license" itemprop="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. 
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
  </p>
  <p class="copyright">Androidtraining maintained by <a href="https://github.com/mixi-inc" itemprop="author">mixi-inc</a></p>
  <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>

</footer>

        </div>
      </paper-scroll-header-panel>
    </paper-drawer-panel>
    <script>
        // custom transformation: scale header's title
        var title = document.querySelectorAll('.title')[2];
        addEventListener('paper-header-transform', function(e) {
            var d = e.detail;
            var m = d.height - d.condensedHeight;
            var scale = Math.max(0.75, (m - d.y) / (m / 0.25)  + 0.75);

            Polymer.Base.transform('scale(' + scale + ') translateZ(0)', title);
        });

    </script>
</body>
</html>
