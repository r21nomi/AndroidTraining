<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="この章では、画面のライフサイクルの管理について解説します。" />
    <meta name=viewport content="width=device-width, initial-scale=1">
    <!-- ogp for twitter -->
    <meta content="@mixi_engineers" name="twitter:site" />
    <meta content="summary" name="twitter:card" />
    
    <meta content="ActivityとFragment - mixi-inc/AndroidTraining" name="twitter:title" />
    
    <meta content="この章では、画面のライフサイクルの管理について解説します。" name="twitter:description" />
    <meta content="/assets/logo.png" name="twitter:image:src" />
    <!-- ogp -->
    <meta content="mixi-inc/AndroidTraining" property="og:site_name" />
    <meta content="article" property="og:type" />
    <meta content="/assets/logo.png" property="og:image" />
    
    <meta content="ActivityとFragment - mixi-inc/AndroidTraining" name="og:title" />
    
    <meta content="/fundamentals/2.02.activity-and-fragment.html" property="og:url" />
    <meta content="この章では、画面のライフサイクルの管理について解説します。" property="og:description" />
    
    <meta name="keyword" content="android, training, 基礎, スキル, 開発, developer, プログラミング, 画面, activity, fragment" />
    

    <meta name="go-import" content="github.com/mixi-inc/AndroidTraining git https://github.com/mixi-inc/AndroidTraining.git">
    <script src="/AndroidTraining/bower_components/webcomponentsjs/webcomponents.js"></script>
    
    <link rel="stylesheet" type="text/css" media="screen" href="/AndroidTraining/stylesheets/main.css">
    <link rel="shortcut icon" href="/AndroidTraining/assets/favicon.ico" />
    <link rel="import" href="/AndroidTraining/bower_components/paper-scroll-header-panel/paper-scroll-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-drawer-panel/paper-drawer-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-header-panel/paper-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-toolbar/paper-toolbar.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-menu/paper-menu.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-item/paper-item.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-icon-button/paper-icon-button.html">
    <link rel="import" href="/AndroidTraining/bower_components/iron-icons/iron-icons.html">
    <style is="custom-style">
        paper-scroll-header-panel:not([style-scope]):not(.style-scope) {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        paper-toolbar.tall .bottom:not([style-scope]):not(.style-scope) {
            font-size: 40px;
            margin-left: 60px;

            -webkit-transform-origin: left center;
            transform-origin: left center;
        }

        .content:not([style-scope]):not(.style-scope) {
            padding: 8px;
        }

        .spacer:not([style-scope]):not(.style-scope) {
            -ms-flex: 1 1 0.000000001px;
            -webkit-flex: 1;
            flex: 1;
            -webkit-flex-basis: 0.000000001px;
            flex-basis: 0.000000001px;
        }

    </style>
    <title>ActivityとFragment - mixi-inc/AndroidTraining</title>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-50931519-13', 'auto');
    ga('send', 'pageview');
    </script>
  </head>

  <body itemscope itemtype="http://schema.org/Article" fullbleed layout vertical>

    <paper-drawer-panel selected="main" >
      <!-- MENU -->
      <paper-header-panel mode="seamed" drawer class="drawer">
        <nav>
    <ol class="chapter_navigation">
        <a href="/AndroidTraining/">Home</a>
        <li>まえがき</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/introductions/1.01.about-android-os.html">Android-OSについて</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.02.prepare-for-development.html">開発環境の準備</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.03.create-project-for-android-studio.html">プロジェクトの作成</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.04.basic-knowledge.html">Androidの基礎知識</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.05.how-to-build-for-gradle.html">Android のビルドについて(Gradle)</a></li>
            
        </ol>
        <li>基礎編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/fundamentals/2.01.create-layout.html">アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.02.activity-and-fragment.html">ActivityとFragment</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.03.application-resource-management.html">アプリのリソース管理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.04.messaging-and-notification.html">メッセージングと通知</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.05.actionbar-and-interaction-control.html">AppBarとインタラクション制御</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.06.listView-and-viewPager.html">ListViewとViewPager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.07.serialize-and-collection-and-perpetuation.html">直列化とコレクション、永続化</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.08.async-processing.html">非同期処理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.09.network-access.html">ネットワーク通信</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.10.database.html">データベース</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing-for-android-studio.html">テスト(AndroidStudio)</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing.html">テスト</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.12.handler-and-looper.html">HandlerとLooper</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.13.webView.html">WebView</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.14.accountmanager.html">AccountManager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.15.advance-contentprovider.html">ContentProviderの発展</a></li>
            
        </ol>
        <li>実務編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-eclipse.html">デバッグと自動ビルド(Eclipse)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-gradle.html">自動ビルド(Android Studio)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.02.architecture-and-di.html">アーキテクチャ設計と DI</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.03.advanced-layout.html">続・アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.04.user-interface.html">ユーザインタフェース設計</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.05.security.html">セキュリティ</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.06.google-api.html">Google API</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.07.google-play-services.html">Google Play Services</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.08.cloud-sync.html">クラウド同期</a></li>
            
        </ol>
        <li>デザイナー編</li>
        <ol>
        </ol>
    </ol>
    <ol class="appex_navigation">
        <li>付録</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/appendix/A.01.import-from-git-for-eclipse.html">Git リポジトリからのプロジェクトのインポート</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.02.basic-java.html">Java の文法の基礎</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.03.how-to-create-avd.html">仮想デバイスの作成</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.04.advanced-java.html">Javaの活用</a></li>
            
        </ol>
    </ol>
</nav>

      </paper-header-panel>
      <paper-scroll-header-panel main condenses>
        <!-- HEADER -->
        <paper-toolbar class="mainheader tall" role="toolbar">
    <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>

    <span class="title"></span>

    <a id="forkme_banner" href="https://github.com/mixi-inc/AndroidTraining" role="button">
        <paper-icon-button src="/AndroidTraining/images/blacktocat.png"></paper-icon-button> <span>View on GitHub</span>
    </a>

    <div class="middle title">mixi-inc/AndroidTraining</div>
    <div class="bottom title">ActivityとFragment</div>
</paper-toolbar>


<div id="description" itemprop="description">この章では、画面のライフサイクルの管理について解説します。</div>



        <!-- MAIN CONTENT -->
        <div id="main_content_wrap" class="content outer" itemprop="articleBody">
          <section id="main_content" class="inner">
            <p>参考：<a href="http://developer.android.com/guide/components/activities.html">Activities | Android Developers</a><br />
参考：<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">Tasks and Back Stack | Android Developers</a></p>

<h2 id="section">目次</h2>

<ul>
  <li><a href="#android-の画面の構成要素">Android の画面の構成要素</a></li>
  <li><a href="#ライフサイクルの管理">ライフサイクルの管理</a>
    <ul>
      <li><a href="#activity">Activity</a></li>
      <li><a href="#fragment">Fragment</a></li>
    </ul>
  </li>
  <li><a href="#androidmanifest-での-activity-の宣言">AndroidManifest での Activity の宣言</a>
    <ul>
      <li><a href="#&lt;activity&gt;要素">&lt;activity&gt;要素</a></li>
      <li><a href="#ランチャーから起動する-activity-の宣言">ランチャーから起動する Activity の宣言</a></li>
    </ul>
  </li>
  <li><a href="#Activity とレイアウトの管理">Activity とレイアウトの管理</a>
    <ul>
      <li><a href="#レイアウトからの View の取得">レイアウトからの View の取得</a></li>
    </ul>
  </li>
  <li><a href="#Fragment の組み込み">Fragment の組み込み</a>
    <ul>
      <li><a href="#レイアウトに記述する">レイアウトに記述する</a></li>
      <li><a href="#FragmentManager と FragmentTransaction で管理する">FragmentManager と FragmentTransaction で管理する</a></li>
      <li><a href="#Fragment の作成の注意点">Fragment の作成の注意点</a></li>
    </ul>
  </li>
  <li><a href="#タスクとバックスタック">タスクとバックスタック</a>
    <ul>
      <li><a href="#タスク">タスク</a></li>
      <li><a href="#バックスタック">バックスタック</a></li>
      <li><a href="#マルチタスク">マルチタスク</a></li>
      <li><a href="#状態の保存と復旧">状態の保存と復旧</a></li>
    </ul>
  </li>
</ul>

<h2 id="android-">Android の画面の構成要素</h2>

<p>Android の画面を作る上で重要なコンポーネントとして、下記のようなものがあります。</p>

<dl>
<dt>Activity</dt>
<dd>MVC の Controller に相当するものです。
画面のライフサイクルや、UI イベントの管理は Activity が受け持っています。</dd>
<dt>Fragment</dt>
<dd>
<p>
再利用可能な UI コンポーネントのまとまりを管理します。Activity に組み込んで使用します。<br />
こちらも、MVC の Controller に相当する責務を持っています。<br />
様々なデバイスをサポートする上でも重要なコンポーネントとなります。
</p>
<p>
Fragment も Activity と同様ライフサイクルを持っていますが、Activity に組み込んで使う為、Activity のライフサイクルと連動するようになっています。
</p>
</dd>
<dt>Layout・Widget</dt>
<dd><a href="/AndroidTraining/fundamentals/2.01.create-layout.html">アプリのレイアウト作成</a>で解説しました。</dd>
</dl>

<h2 id="section-1">ライフサイクルの管理</h2>

<h3 id="activity">Activity</h3>

<p>Activity にはライフサイクルが存在します。
主には、画面が呼び出されてから、必要なくなってメモリから追い出される（破棄される）までの一連の流れをライフサイクルとして扱います。
以下に上げるライフサイクルの各状態は、ライフサイクルコールバックとして、Activity クラスに同じ名前で定義されています。</p>

<p><img src="/AndroidTraining/assets/02-02/activity_lifecycle.png" alt="Activity Lifecycle" /></p>

<dl>
<dt>onCreate</dt>
<dd>
<p>
Activity が一番最初にとる状態です。
</p>
<p>
Activity が起動し、画面を構成するまでの仕事をここで行います。<br />
XML で定義したレイアウトを読み込んだり、View コンポーネントを取り出したりする処理を実行します。
</p>
<pre>
public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // レイアウトを指定して、Activity がコントロールする View として扱うようにする
        setContentView(R.layout.activity_main);
    }
}
</pre>
</dd>
<dt>onStart(onRestart)</dt>
<dd>Activity の画面が構築され、ユーザに見える状態です。実際にユーザが UI に触れてインタラクションを実施出来るようになるまでの仕事をここで行います。</dd>
<dt>onResume</dt>
<dd>Activity の画面が構築され、ユーザが UI に触れてインタラクションを実施できる状態です。</dd>
<dt>onPause</dt>
<dd>
<p>
ユーザが Activity を離れようとしている状態です。永続化するべき情報はこのタイミングで永続化を実施します。
</p>
<p>
この状態になった Activity へユーザが戻ると、onResume の状態へと遷移します。
よって、この状態になっても、必ずこの後の状態へ順に遷移して、Activity がメモリから破棄されるとは限りません。
</p>
</dd>
<dt>onStop</dt>
<dd>
<p>
Activity がユーザから見えなくなった状態です。
</p>
<p>
この状態になった Activity にユーザが戻ろうとした場合、onRestart の状態から onStart の状態へと遷移します。
</p>
</dd>
<dt>onDestroy</dt>
<dd>
<p>
Activity がシステムによって、メモリから追い出される直前の状態です。
</p>
<p>
この時点で、Activity に対するすべての参照を切っておかないと、メモリリークを起こします。<br />
一方、システムの要求によって、アプリのプロセスごと kill された場合には、この状態になることなくアプリケーションが終了します。
</p>
</dd>
</dl>

<h3 id="fragment">Fragment</h3>

<p>Fragment にもライフサイクルが存在します。</p>

<p>基本的には、Activity のライフサイクルと同じ状態を持っていますが、いくつか Fragment 特有の状態も持っています。<br />
以下に上げるライフサイクルの各状態は、ライフサイクルコールバックとして、Fragment クラスに同じ名前で定義されています。</p>

<p><img src="/AndroidTraining/assets/02-02/fragment_lifecycle.png" alt="Fragment Lifecycle" /></p>

<p>Fragment は、Honeycomb で導入された新しいコンポーネントです。</p>

<p>Eclipse では、android.app.Fragment と android.support.v4.app.Fragment の 2 つがコード補完によって表示されますが、2.x 系で Fragment を使用する場合は、後者のパッケージのものを利用します。</p>

<p>また同時に、2.x 系で Fragment を組み込んだ Activity を作成する場合は、android.app.Activity ではなく、android.support.v4.app.FragmentActivity を継承するようにします。</p>

<dl>
<dt>onAttach</dt>
<dd>
<p>
Fragment が Activity に組み込まれた状態です。<br />
この時点で、Fragment が Activity に対して何らかのコールバックを提供する場合、Activity が必要なインタフェースを備えているかどうかチェックしておきます。
</p>

<pre>
public class MainFragment extends Fragment {
    private FragmentCallbacks mCallback;
	
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        try {
            mCallback = (FragmentCallbacks) activity;
        } catch (ClassCastException e) {
            // Fragment が組み込まれる先の Activity に対して、FragmentCallbacks インタフェースの実装を要求する為
            // キャストに失敗した場合は、実行時例外としてプログラムのミスであることを示す 
            throw new IllegalStateException("activity should implement FragmentCallbacks", e);
        }
    }

    public static interface FragmentCallbacks {
        public void onHogehoge();
    }
}
</pre>
</dd>
<dt>onCreate</dt>
<dd>
<p>
Fragment を構築する状態です。
</p>
<p>
Fragment がユーザに見える状態になるまで保持しておくべきコンポーネントの初期化を行います。
</p>
</dd>
<dt>onCreateView</dt>
<dd>
<p>
Fragment が持つ View を構築する状態です。
</p>
<p>
XML からレイアウトを取り出し、この Fragment の View として扱うための処理を行いますが、View を持たない Fragment を作ることも可能です。
</p>

<pre>
public class MainFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        // LayoutInflater を利用して、レイアウトをリソースとして読み込む
        View view = inflater.inflate(R.layout.fragment_main, container, false);
        return view;
    }
}
</pre>

<pre>
public class MainFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        // View を持たない Fragment は、ここで null を返す
        return null;
    }
}
</pre>
</dd>
<dt>onActivityCreated</dt>
<dd>Activity の onCreate の状態の処理が終わったことを示す状態です。</dd>
<dt>onStart</dt>
<dd>Fragment の UI が構築され、ユーザに見える状態です。</dd>
<dt>onResume</dt>
<dd>Fragment の UI が構築され、ユーザとのインタラクションが出来るようになった状態です。</dd>
<dt>onPause</dt>
<dd>
<p>
ユーザが別の画面への遷移をしようとして Fragment から離れていこうとした状態です。</p>
<p>
Activity と同じく、この時点で、永続化するべき情報を保存するようにしておきます。<br />
ただし、この状態になったからといって、必ずしもこの後の状態へ遷移し、Fragment がメモリから破棄されるわけではありません。
</p>
</dd>
<dt>onStop</dt>
<dd>Fragment がユーザに見えない状態です。</dd>
<dt>onDestroyView</dt>
<dd>
<p>Fragment が扱う View などのコンポーネントに紐付いた各種リソースを開放するための状態です。</p>
<p>
ここで Fragment への参照が View やコンポーネントに残っていると、メモリリークを起こします。<br />
ユーザのナビゲーションや Fragment の操作等で、再びレイアウトにアタッチされる場合、onCreateView の状態へ戻ります。
</p>
</dd>
<dt>onDestroy</dt>
<dd>Fragment が完全にメモリから破棄される直前の状態です。</dd>
<dt>onDetach</dt>
<dd>Fragment が Activity から切り離される状態です。</dd>
</dl>

<h2 id="androidmanifest--activity-">AndroidManifest での Activity の宣言</h2>

<p>AndroidManifest は XML で記述されています。
Activity は、アプリケーションを構成するコンポーネントですので、 <code class="highlighter-rouge">&lt;application&gt;</code>要素の下にぶら下げる形で宣言します。</p>

<h3 id="activity-1"><code class="highlighter-rouge">&lt;activity&gt;</code>要素</h3>

<p><code class="highlighter-rouge">&lt;activity&gt;</code>要素には、どの Activity かを示したり、Activity のラベルを示したりする属性を付与できます。
以下に、代表的な属性を示します。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;activity</span>
  <span class="na">android:name=</span><span class="s">"string"</span>
  <span class="na">android:label=</span><span class="s">"string"</span>
  <span class="na">android:exported=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
  <span class="na">android:launchMode=</span><span class="s">["multiple"</span> <span class="err">|</span> <span class="err">"singleTop"</span> <span class="err">|</span> <span class="err">"singleTask"</span> <span class="err">|</span> <span class="err">"singleInstance"]</span>
  <span class="na">android:configChanges=</span><span class="s">["mcc",</span> <span class="err">"mnc",</span> <span class="err">"locale",</span> <span class="err">"touchscreen",</span> <span class="err">"keyboard",</span> <span class="err">"keyboardHidden",</span> <span class="err">"navigation",</span> <span class="err">"screenLayout",</span> <span class="err">"fontScale",</span> <span class="err">"uiMode",</span> <span class="err">"orientation",</span> <span class="err">"screenSize",</span> <span class="err">"smallestScreenSize"]</span>
  <span class="na">android:theme=</span><span class="s">"resource or theme"</span>
  <span class="na">android:uiOptions=</span><span class="s">["none"</span> <span class="err">|</span> <span class="err">"splitActionBarWhenNarrow"]</span>
  <span class="na">android:windowSoftInputMode=</span><span class="s">["stateUnspecified",</span> <span class="err">"stateUnchanged",</span> <span class="err">"stateHidden",</span> <span class="err">"stateAlwaysHidden",</span> <span class="err">"stateVisible",</span> <span class="err">"stateAlwaysVisible",</span> <span class="err">"adjustUnspecified",</span> <span class="err">"adjustResize",</span> <span class="err">"adjustPan"]</span><span class="nt">&gt;</span>
<span class="nt">&lt;/activity&gt;</span>
</code></pre>
</div>

<table>
  <thead>
    <tr>
      <th>要素</th>
      <th>意味</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>android:name</td>
      <td>Activity のクラス名。FQDN か、<code class="highlighter-rouge">&lt;application&gt;</code>要素で宣言したパッケージ名から後ろのパス表現で記述する</td>
    </tr>
    <tr>
      <td>android:label</td>
      <td>Activity のラベル。ユーザに見えるものなので、分かりやすいものにしておく</td>
    </tr>
    <tr>
      <td>android:exported</td>
      <td>他のアプリからも呼び出すことができるようにするかどうか。デフォルトではfalseになるが、例外的に、<code class="highlighter-rouge">&lt;intent-filter&gt;</code>要素を子要素に持つ<code class="highlighter-rouge">&lt;activity&gt;</code>は、この属性がデフォルトでtrueになることに注意。特に理由がない限りは、falseを明示すること</td>
    </tr>
    <tr>
      <td>android:configChanges</td>
      <td>Activity が自身で制御するコンフィギュレーション変化の一覧。複数指定が可能で、パイプで繋ぐ</td>
    </tr>
    <tr>
      <td>android:theme</td>
      <td>Activity に適用するテーマ</td>
    </tr>
    <tr>
      <td>android:uiOptions</td>
      <td>Activity に適用する、UI にまつわる設定。現状は ActionBar の設定のみが存在している</td>
    </tr>
    <tr>
      <td>android:windowSoftInputMode</td>
      <td>ソフトウェアキーボードと Activity の表示に関する調整要素。ソフトウェアキーボードを自動で表示するかどうかや、Activity の拡大・縮小についての振る舞いを決める</td>
    </tr>
  </tbody>
</table>

<h3 id="activity-">ランチャーから起動する Activity の宣言</h3>

<p>アプリを起動する時、ランチャーは、当該アプリに対して、暗黙的 Intent を発行します（Intent は、Android の各種コンポーネントを結びつけるためのメッセージオブジェクトです。新しい Activity を呼び出すときにも、この Intent を利用しています）。
この暗黙的 Intent を受け付けることの出来る Activity の宣言の例を以下に示します。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
    <span class="na">package=</span><span class="s">"jp.mixi.sample"</span>
    <span class="na">android:versionCode=</span><span class="s">"1"</span>
    <span class="na">android:versionName=</span><span class="s">"1.0"</span> <span class="nt">&gt;</span>

    <span class="nt">&lt;uses-sdk</span>
        <span class="na">android:minSdkVersion=</span><span class="s">"8"</span>
        <span class="na">android:targetSdkVersion=</span><span class="s">"17"</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;application</span>
        <span class="na">android:allowBackup=</span><span class="s">"true"</span>
        <span class="na">android:icon=</span><span class="s">"@drawable/ic_launcher"</span>
        <span class="na">android:label=</span><span class="s">"@string/app_name"</span>
        <span class="na">android:theme=</span><span class="s">"@style/AppTheme"</span> <span class="nt">&gt;</span>
        <span class="c">&lt;!-- Activity に関する宣言 --&gt;</span>
        <span class="c">&lt;!-- 新しい Activity を作ったら、必ずこの宣言を追加する --&gt;</span>
        <span class="c">&lt;!-- android:name には、FQDN か、jp.mixi.sampleの続きからのパスを入れる --&gt;</span>
        <span class="nt">&lt;activity</span>
            <span class="na">android:name=</span><span class="s">"jp.mixi.sample.MainActivity"</span>
            <span class="na">android:label=</span><span class="s">"@string/app_name"</span> <span class="nt">&gt;</span>
            <span class="c">&lt;!-- ランチャーから呼び出す対象とするための宣言 --&gt;</span>
            <span class="c">&lt;!-- ランチャーから呼び出さない Activity であれば、この宣言は不要 --&gt;</span>
            <span class="nt">&lt;intent-filter&gt;</span>
                <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.intent.action.MAIN"</span> <span class="nt">/&gt;</span>

                <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">"android.intent.category.LAUNCHER"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/intent-filter&gt;</span>
        <span class="nt">&lt;/activity&gt;</span>
    <span class="nt">&lt;/application&gt;</span>

<span class="nt">&lt;/manifest&gt;</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">&lt;activity&gt;</code>要素の子要素として、<code class="highlighter-rouge">&lt;intent-filter&gt;</code>要素を宣言します。
この<code class="highlighter-rouge">&lt;intent-filter&gt;</code>要素に更に子要素として、Intent に付与される Action と Category を指定します。</p>

<p>ランチャーからの呼び出しでは、android.intent.action.MAIN というアクションと、android.intent.category.LAUNCHER というカテゴリが付与されますので、これを<code class="highlighter-rouge">&lt;intent-filter&gt;</code>要素の子要素に宣言しておきます。</p>

<h2 id="activity--1">Activity とレイアウトの管理</h2>

<h3 id="activity--2">Activity が管理するレイアウトの指定</h3>

<p><code class="highlighter-rouge">Activity#onCreate(Bundle)</code>の中で、<code class="highlighter-rouge">Activity#setContentView(int)</code>を呼び出します。<br />
呼び出すメソッドの引数に渡す int 型整数は、レイアウトファイルの id です。<br />
レイアウトファイルの id は、R クラスで管理されており、レイアウトファイルを作成すると自動で生成されます。</p>

<pre><code class="language-Java">public class MyActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // activity_main.xml をこの Activity のレイアウトとして管理する場合
        setContentView(R.layout.activity_main);
    }
}
</code></pre>

<h3 id="view-">レイアウトからの View の取得</h3>

<p>View に<code class="highlighter-rouge">android:id</code>が割当てられていれば、この id を元に、View の取得をすることが出来ます。<br />
id を元に View を取得するメソッドに、<code class="highlighter-rouge">Activity#findViewById(int)</code>があります。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;TextView</span>
    <span class="na">android:id=</span><span class="s">"@+id/MyTextView"</span>
    <span class="na">android:layout_width=</span><span class="s">"wrap_content"</span>
    <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<pre><code class="language-Java">public class MyActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // findViewById の引数に、View に割り当てた id を指定する
        // View オブジェクトが返ってくるので、適宜キャストする
        TextView view = (TextView) findViewById(R.id.MyTextView);
    }
}
</code></pre>

<h2 id="fragment-">Fragment の組み込み</h2>

<p>2 種類の組み込み方があります。</p>

<h3 id="section-2">レイアウトに記述する</h3>

<p>Activity で使うレイアウトの XML の中で、<code class="highlighter-rouge">&lt;fragment&gt;</code>タグを利用して記述する方法です。</p>

<p>もっとも単純な Fragment の使い方です。</p>

<p>レイアウトで使用する各種属性の他に、<code class="highlighter-rouge">android:id</code>属性と、<code class="highlighter-rouge">android:name</code>属性を必ず指定します。<br />
<code class="highlighter-rouge">android:name</code>属性は、Fragment のクラス名を FQDN で記述します。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="c">&lt;!-- Activity 用のレイアウトでの Fragment の宣言。andorid:id によって、状態管理を行なっている --&gt;</span>
<span class="nt">&lt;LinearLayout</span>
        <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>

        <span class="err">&lt;!--</span> <span class="err">何かしらの他の</span> <span class="err">Viewたち...</span> <span class="err">--</span><span class="nt">&gt;</span>

        <span class="c">&lt;!-- fragment の宣言。android:name に指定する Fragmentの名前は FQDN で書く。 --&gt;</span>
        <span class="nt">&lt;fragment</span>
                <span class="na">android:id=</span><span class="s">"@+id/MyFragment"</span>
                <span class="na">android:name=</span><span class="s">"jp.mixi.sample.fragment.MyListFragment"</span>
                <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
                <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/LinearLayout&gt;</span>
</code></pre>
</div>

<p>レイアウトに定義された Fragment を Activity で取り出すには、FragmentManager を利用します。</p>

<pre><code class="language-Java">public class MyActivity extends FragmentActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // FragmentManager も、android.support.v4.app.FragmentManager を利用する
        FragmentManager manager = getSupportFragmentManager();
        // レイアウトから Fragment を見つけ出してインスタンスを得る
        Fragment fragment = manager.findFragmentById(R.id.MyFragment);
    }
}
</code></pre>

<h3 id="fragmentmanager--fragmenttransaction-">FragmentManager と FragmentTransaction で管理する</h3>

<p>画面(Activity)の中で、動的に Fragment を切り替える場合を考えると、レイアウトに書いてしまうと実現が難しくなります。<br />
そこで、Activity の中で動的に Fragment を切り替える仕組みも用意されています。</p>

<p>動的に Fragment を切り替える場合は、Fragment を保持するためだけの Layout を用意しておく必要があります。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="c">&lt;!-- Activity 用のレイアウトでの Fragment の宣言。andorid:id によって、状態管理を行なっている --&gt;</span>
<span class="nt">&lt;LinearLayout</span>
        <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>

        <span class="err">&lt;!--</span> <span class="err">何かしらの他の</span> <span class="err">Viewたち...</span> <span class="err">--</span><span class="nt">&gt;</span>

        <span class="c">&lt;!-- Fragment を動的に入れ替えるための入れ物用のレイアウト --&gt;</span>
        <span class="nt">&lt;FrameLayout</span>
            <span class="na">android:id=</span><span class="s">"@+id/FragmentContainer"</span>
            <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
            <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/LinearLayout&gt;</span>
</code></pre>
</div>

<p>FragmentManager で、FragmentTransaction を開始し、この Transaction の中で、動的に Fragment の切り替えを行います。</p>

<pre><code class="language-Java">public class MyActivity extends FragmentActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        FragmentManager manager = getSupportFragmentManager();
        // FragmentTransaction を開始
        FragmentTransaction transaction = manager.beginTransaction();

        // FragmentContainer のレイアウトに、MyFragment を割当てる
        transaction.add(R.id.FragmentContainer, MyFragment.createInstance());

        // FragmentContainer のレイアウトの中身を、MyFragment に置き換える
        transaction.replace(R.id.FragmentContainer, MyFragment.createInstance());

        // Fragment を削除する
        transaction.remove(mFragment);

        // 変更を確定して FragmentTransaction を終える
        transaction.commit();
    }
}
</code></pre>

<h3 id="fragment--1">Fragment の作成の注意点</h3>

<p>Fragment のクラスを作成するときには、以下の点に注意してください。</p>

<dl>
<dt>空のコンストラクタを定義する</dt>
<dd>
何もしなくても、空のコンストラクタが必要です。これは、Android のフレームワークが、リフレクションによって、Fragment のデフォルトコンストラクタを呼び出すためです。
<pre>
public class MyFragment extends Fragment {
    public MyFragment() {}
}
</pre>
</dd>
<dt>Fragment のインスタンス化にはコンストラクタを使わない</dt>
<dd>
<p>
Fragment を動的に管理する際に必要なノウハウです。<br />
Fragment のインスタンス化の際、Fragment に対して、引数を何かしら渡したい場合がありますが、このためにコンストラクタや setter メソッドを使ってはいけません。<br />
これは、Android のフレームワークが、Fragment の状態の復旧時に、デフォルトコンストラクタを呼び出すためです。つまり、setter メソッドを定義しても、フレームワークは全くその存在を気にすることが出来ない為、setter メソッドも意味を成さなくなります。
</p>
<p>
代わりに、Fragment の初期化のために、専用の static メソッドを用意し、引数を渡す場合は、`Fragment#setArguments(Bundle)`を利用して、Bundle に引数として渡したいデータを詰め込みます。
</p>
<pre>
public class MyFragment extends Fragment {
    public MyFragment() {}

    // 初期化専用のメソッド。Fragment に対する初期化用の引数はここで管理する
    public static Fragment createInstance(int hoge) {
        Fragment fragment = new MyFragment();
        // Fragment に渡す引数を詰めこむオブジェクト
        Bundle args = new Bundle();
        args.putInt("hoge", hoge);

        // 詰め込んだオブジェクトを Fragment に渡す
        fragment.setArguments(args);

        // 新しいインスタンスを返す
        return fragment;
    }
}
</pre>
</dd>
</dl>

<h2 id="section-3">タスクとバックスタック</h2>

<p>Android には、タスクとバックスタックという考え方があります。
この考え方が取り扱うのは、複数の Activity の管理です。
同一アプリ内で扱う複数の Activity だけでなく、他のアプリとの連携も、タスクとバックスタックの扱う範囲です。</p>

<h3 id="section-4">タスク</h3>

<p>タスクとは、ユーザがアプリを利用して何らかの操作を行う単位です。このことから、Linux などで用いられるタスクとは異なる意味を持っています。</p>

<p>1つのタスクには、起動した Activity のまとまりをスタックで持つバックスタックが割当てられます。</p>

<h3 id="section-5">バックスタック</h3>

<p>バックスタックとは、Activity の呼び出し順を管理するスタックです。
アプリを起動すると、最初にランチャーから呼び出される Activity がバックスタックに積まれます（push）。</p>

<p>その Activity から新しい別の Activity を呼び出すと、その Activity がバックスタックに積まれます（push）。
新しく起動した Activity で、端末のバックキー（戻るボタン）を押すなどして前の Activity に戻ると、バックスタックに積まれていた Activity は破棄されます（pop）。</p>

<p>すべての Activity がバックスタックから居なくなると、アプリケーションは終了することとなります。</p>

<p><img src="/AndroidTraining/assets/02-02/diagram_backstack.png" alt="Back Stack Visualization" /></p>

<h3 id="section-6">マルチタスク</h3>

<p>あるタスクのバックスタックに Activity が積まれている状態で、ユーザがホームキーで端末のホーム画面に戻った場合、タスクはバックグラウンドで待機状態となります。</p>

<p>この時、別のアプリを起動すると、新たな別のタスクが定義され、新しいタスクのバックスタックに起動したアプリの Activity が積まれます。
つまり、新しいタスクはフォアグラウンドで実行中の状態となります。</p>

<p>ここで、ユーザが再びホームキーでホーム画面に戻り、最初に利用していたアプリを起動してバックグラウンドに居たタスクをフォアグラウンドへ遷移させると、もう一方のフォアグラウンドに居たタスクがバックグラウンドへ移ります。</p>

<p><img src="/AndroidTraining/assets/02-02/diagram_multitasking.png" alt="Multi-Task Visualization" /></p>

<p>これが Android のマルチタスクです。</p>

<p>マルチタスクで多数のタスクをバックグラウンドへ移すと、その分だけメモリを消費します。メモリ残量が少なくなると、システムは、バックグラウンドに居るタスクのなかから、優先順位を見てタスクの持つ Activity の破棄を試みます。</p>

<p>Activity が破棄されても、破棄される前の状態に復元できるよう、Activity のライフサイクルにしたがって実装をしておくべきです。</p>

<h3 id="section-7">状態の保存と復旧</h3>

<p>Activity には、以下の二つのコールバックメソッドが用意されており、これらを活用して、状態の保存と復旧を行います。</p>

<dl>
<dt>onSaveInstanceState</dt>
<dd>
Activity が破棄される前に、状態を保存するために呼ばれるコールバックメソッドです。

引数に Bundle オブジェクト（Android 独自のコレクション・フレームワーク）が渡されるので、このオブジェクトに状態を保存します。
</dd>
<dt>onRestoreInstanceState</dt>
<dd>
Activity が再度フォアグラウンドに遷移する際、状態を復旧するために呼ばれるコールバックメソッドです。

引数に Bundle オブジェクトが渡されます。この Bundle オブジェクトには、onSaveInstanceState() メソッドで保存した状態が入っていますので、その状態を取り出して復旧します。

Activity の onCreate() メソッドの引数にある Bundle オブジェクトも同じ役割を持っています。
</dd>
</dl>

<p>同様、Fragment にも onSaveInstanceState() メソッドが定義されており、ここで状態の保存をすることができます。</p>

<p>一方、状態の復旧には、onCreate() や onCreateView()、onActivityCreated() メソッドの引数にある Bundle オブジェクトを利用します。</p>

<h3 id="launch-mode">Launch Mode</h3>

<p>Activity のインスタンスをどのようにスタック上で管理するかを決めるモードです。<br />
このモードの宣言は、AndroidManifest の <code class="highlighter-rouge">&lt;activity&gt;</code>要素で行います。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;activity</span>
    <span class="err">...</span>
    <span class="na">android:launchMode=</span><span class="s">"singleTop"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<table>
  <thead>
    <tr>
      <th>モード名</th>
      <th>意味</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>standard</td>
      <td>デフォルトのモード。Activity の呼び出しごとに毎回インスタンスを生成する為、複数の同じActivityのインスタンスがスタック上に現れる。</td>
    </tr>
    <tr>
      <td>singleTop</td>
      <td>Activity を呼び出した時、スタックの一番上にその Activity のインスタンスがあるときは、<code class="highlighter-rouge">Activity#onNewIntent()</code>を呼び出して、そこに新しい Intent を送りつける</td>
    </tr>
    <tr>
      <td>singleTask</td>
      <td>新しいタスクのルートとして Activity のインスタンスを生成するが、既にタスクのスタックにインスタンスがある場合は、<code class="highlighter-rouge">Activity#onNewIntent()</code>を呼び出して、新しいタスクのルートに据える</td>
    </tr>
    <tr>
      <td>singleInstance</td>
      <td>タスクの中で、Activity のインスタンスは常に 1 つで、かつそのインスタンスが属するタスクの中では、他の Activity を起動させない</td>
    </tr>
  </tbody>
</table>

<p>殆どの場合、standard モードないしは singleTop モードを利用することになります。<br />
公式のリファレンスにも書かれている通り、ほとんどのアプリケーションにおいて、singleTaks や singleInstance は不適切なモードです。</p>

<h2 id="section-8">実習・課題</h2>

<h3 id="section-9">実習</h3>

<h4 id="activity-2">Activity</h4>

<ol>
  <li>新しい Activity と、それに対応するレイアウトを作成してください。<br />
(使用するプロジェクト: AndroidStudio/practice/fundamentals/2nd/ActivityPractice/practice1/app/build.gradle)</li>
  <li>1で作った Activity を、アプリ起動時に表示するよう変更してください。
(変更先のプロジェクト: AndroidStudio/practice/fundamentals/2nd/ActivityPractice/practice2/app/build.gradle)</li>
</ol>

<h4 id="fragment-1">Fragment</h4>

<ol>
  <li>新しい Fragment と、それに対応するレイアウトを作成してください。<br />
(使用するプロジェクト: AndroidStudio/practice/fundamentals/2nd/FragmentPractice/practice1/app/build.gradle)</li>
  <li>1で作った Fragment を、既存の Activity に組み込んでください。
(変更先のプロジェクト: AndroidStudio/practice/fundamentals/2nd/FragmentPractice/practice2/app/build.gradle)</li>
</ol>

<h3 id="section-10">課題</h3>

<ol>
  <li><code class="highlighter-rouge">Toast#makeText(Context, int, int)</code>メソッド(<a href="http://developer.android.com/reference/android/widget/Toast.html#makeText(android.content.Context, int, int)">仕様</a>)を使って、Activity のライフサイクルのコールバックメソッドが、どのような順番で実行されるかを画面に表示し、列挙してください。<br />
(使用するプロジェクト: AndroidStudio/assignments/fundamentals/2nd/ControllerAssignment1/build.gradle)</li>
  <li>Activity が 2 つ用意されています。起動後の Activity から呼び出された Activity で、状態管理を適切に行なってください（ControllerLifecycleAssignment2 プロジェクトを使う）。<br />
(使用するプロジェクト: AndroidStudio/assignments/fundamentals/2nd/ControllerAssignment2/build.gradle)</li>
  <li><code class="highlighter-rouge">activity_main.xml</code>から、Fragment に切り出すものを適宜選択し、Fragment 化してください。<br />
(使用するプロジェクト: AndroidStudio/assignments/fundamentals/2nd/ControllerAssignment3/build.gradle)</li>
  <li>課題 3 で切り出した Fragment を用いて、新しい画面を作成してください（課題 3 と同じプロジェクトの中で実施する）。</li>
  <li>Activity で発生しているメモリリークを特定し、解消してください。<br />
(使用するプロジェクト: AndroidStudio/assignments/fundamentals/2nd/ControllerAssignment4/build.gradle)</li>
</ol>

          </section>
        </div>

        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
          <footer class="inner">
  <p class="license">Portions of this page are reproduced from work created and <a href="https://code.google.com/p/android/">shared by the Android Open Source Project</a> and used according to terms described in the <a href="http://creativecommons.org/licenses/by/2.5/">Creative Commons2.5 Attribution License</a>.</p>
  <p class="license">
  This work is licensed under a <a rel="license" itemprop="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. 
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
  </p>
  <p class="copyright">Androidtraining maintained by <a href="https://github.com/mixi-inc" itemprop="author">mixi-inc</a></p>
  <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>

</footer>

        </div>
      </paper-scroll-header-panel>
    </paper-drawer-panel>
    <script>
        // custom transformation: scale header's title
        var title = document.querySelectorAll('.title')[2];
        addEventListener('paper-header-transform', function(e) {
            var d = e.detail;
            var m = d.height - d.condensedHeight;
            var scale = Math.max(0.75, (m - d.y) / (m / 0.25)  + 0.75);

            Polymer.Base.transform('scale(' + scale + ') translateZ(0)', title);
        });

    </script>
</body>
</html>
