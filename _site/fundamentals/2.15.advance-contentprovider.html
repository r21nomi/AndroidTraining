<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="この章では、ContentProvider の発展的な使用について解説します。" />
    <meta name=viewport content="width=device-width, initial-scale=1">
    <!-- ogp for twitter -->
    <meta content="@mixi_engineers" name="twitter:site" />
    <meta content="summary" name="twitter:card" />
    
    <meta content="ContentProviderの発展 - r21nomi/AndroidTraining" name="twitter:title" />
    
    <meta content="この章では、ContentProvider の発展的な使用について解説します。" name="twitter:description" />
    <meta content="/assets/logo.png" name="twitter:image:src" />
    <!-- ogp -->
    <meta content="r21nomi/AndroidTraining" property="og:site_name" />
    <meta content="article" property="og:type" />
    <meta content="/assets/logo.png" property="og:image" />
    
    <meta content="ContentProviderの発展 - r21nomi/AndroidTraining" name="og:title" />
    
    <meta content="/fundamentals/2.15.advance-contentprovider.html" property="og:url" />
    <meta content="この章では、ContentProvider の発展的な使用について解説します。" property="og:description" />
    
    <meta name="keyword" content="android, training, 基礎, スキル, 開発, developer, プログラミング, Content Provider, データの同期" />
    

    <meta name="go-import" content="github.com/mixi-inc/AndroidTraining git https://github.com/mixi-inc/AndroidTraining.git">
    <script src="/AndroidTraining/bower_components/webcomponentsjs/webcomponents.js"></script>
    
    <link rel="stylesheet" type="text/css" media="screen" href="/AndroidTraining/stylesheets/main.css">
    <link rel="shortcut icon" href="/AndroidTraining/assets/favicon.ico" />
    <link rel="import" href="/AndroidTraining/bower_components/paper-scroll-header-panel/paper-scroll-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-drawer-panel/paper-drawer-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-header-panel/paper-header-panel.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-toolbar/paper-toolbar.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-menu/paper-menu.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-item/paper-item.html">
    <link rel="import" href="/AndroidTraining/bower_components/paper-icon-button/paper-icon-button.html">
    <link rel="import" href="/AndroidTraining/bower_components/iron-icons/iron-icons.html">
    <style is="custom-style">
        paper-scroll-header-panel:not([style-scope]):not(.style-scope) {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        paper-toolbar.tall .bottom:not([style-scope]):not(.style-scope) {
            font-size: 40px;
            margin-left: 60px;

            -webkit-transform-origin: left center;
            transform-origin: left center;
        }

        .content:not([style-scope]):not(.style-scope) {
            padding: 8px;
        }

        .spacer:not([style-scope]):not(.style-scope) {
            -ms-flex: 1 1 0.000000001px;
            -webkit-flex: 1;
            flex: 1;
            -webkit-flex-basis: 0.000000001px;
            flex-basis: 0.000000001px;
        }

    </style>
    <title>ContentProviderの発展 - r21nomi/AndroidTraining</title>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-50931519-13', 'auto');
    ga('send', 'pageview');
    </script>
  </head>

  <body itemscope itemtype="http://schema.org/Article" fullbleed layout vertical>

    <paper-drawer-panel selected="main" >
      <!-- MENU -->
      <paper-header-panel mode="seamed" drawer class="drawer">
        <nav>
    <ol class="chapter_navigation">
        <a href="/AndroidTraining/">Home</a>
        <li>まえがき</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/introductions/1.01.about-android-os.html">Android-OSについて</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.02.prepare-for-development.html">開発環境の準備</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.03.create-project-for-android-studio.html">プロジェクトの作成</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.04.basic-knowledge.html">Androidの基礎知識</a></li>
            
            <li><a href="/AndroidTraining/introductions/1.05.how-to-build-for-gradle.html">Android のビルドについて(Gradle)</a></li>
            
        </ol>
        <li>基礎編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/fundamentals/2.01.create-layout.html">アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.02.activity-and-fragment.html">ActivityとFragment</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.03.application-resource-management.html">アプリのリソース管理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.04.messaging-and-notification.html">メッセージングと通知</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.05.actionbar-and-interaction-control.html">ActionBarとインタラクション制御</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.06.listView-and-viewPager.html">ListViewとViewPager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.07.serialize-and-collection-and-perpetuation.html">直列化とコレクション、永続化</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.08.async-processing.html">非同期処理</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.09.network-access.html">ネットワーク通信</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.10.database.html">データベース</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing-for-android-studio.html">テスト(AndroidStudio)</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.11.testing.html">テスト</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.12.handler-and-looper.html">HandlerとLooper</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.13.webView.html">WebView</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.14.accountmanager.html">AccountManager</a></li>
            
            <li><a href="/AndroidTraining/fundamentals/2.15.advance-contentprovider.html">ContentProviderの発展</a></li>
            
        </ol>
        <li>実務編</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-eclipse.html">デバッグと自動ビルド(Eclipse)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.01.build-for-gradle.html">自動ビルド(Android Studio)</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.02.architecture-and-di.html">アーキテクチャ設計と DI</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.03.advanced-layout.html">続・アプリのレイアウト作成</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.04.user-interface.html">ユーザインタフェース設計</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.05.security.html">セキュリティ</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.06.google-api.html">Google API</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.07.google-play-services.html">Google Play Services</a></li>
            
            <li><a href="/AndroidTraining/advanced/3.08.cloud-sync.html">クラウド同期</a></li>
            
        </ol>
        <li>デザイナー編</li>
        <ol>
        </ol>
    </ol>
    <ol class="appex_navigation">
        <li>付録</li>
        <ol class="section_navigation">
            
            
            <li><a href="/AndroidTraining/appendix/A.01.import-from-git-for-eclipse.html">Git リポジトリからのプロジェクトのインポート</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.02.basic-java.html">Java の文法の基礎</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.03.how-to-create-avd.html">仮想デバイスの作成</a></li>
            
            <li><a href="/AndroidTraining/appendix/A.04.advanced-java.html">Javaの活用</a></li>
            
        </ol>
    </ol>
</nav>

      </paper-header-panel>
      <paper-scroll-header-panel main condenses>
        <!-- HEADER -->
        <paper-toolbar class="mainheader tall" role="toolbar">
    <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>

    <span class="title"></span>

    <a id="forkme_banner" href="https://github.com/mixi-inc/AndroidTraining" role="button">
        <paper-icon-button src="/AndroidTraining/images/blacktocat.png"></paper-icon-button> <span>View on GitHub</span>
    </a>

    <div class="middle title">r21nomi/AndroidTraining</div>
    <div class="bottom title">ContentProviderの発展</div>
</paper-toolbar>


<div id="description" itemprop="description">この章では、ContentProvider の発展的な使用について解説します。</div>



        <!-- MAIN CONTENT -->
        <div id="main_content_wrap" class="content outer" itemprop="articleBody">
          <section id="main_content" class="inner">
            <p>参考：<a href="http://developer.android.com/guide/topics/providers/content-provider-basics.html">Content Provider Basics | Android Developers</a><br />
参考：<a href="http://developer.android.com/training/sync-adapters/index.html">Transferring Data Using Sync Adapter | Android Developers</a><br />
参考：<a href="http://developer.android.com/reference/android/content/ContentResolver.html">ContentResolver | Android Developers</a><br />
参考：<a href="http://developer.android.com/reference/android/content/ContentProviderOperation.html">ContentProviderOperation | Android Developers</a><br />
参考：<a href="http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html">AbstractThreadedSyncAdapter | Android Developers</a></p>

<h2 id="section">目次</h2>

<ul>
  <li><a href="#ContentProvider へのアクセス">ContentProvider へのアクセス</a>
    <ul>
      <li>バッチ処理</li>
      <li>Intent によるアクセス</li>
    </ul>
  </li>
  <li><a href="#データの同期">データの同期</a>
    <ul>
      <li>ContentProvider を用いた同期の仕組み</li>
      <li>同期の仕組みを使用する準備</li>
      <li>AbstractThreadedSyncAdapter</li>
      <li>Service</li>
      <li>メタデータの宣言</li>
      <li>AndroidManifest の宣言</li>
      <li>同期の実行と下位互換</li>
    </ul>
  </li>
</ul>

<h2 id="contentprovider-">ContentProvider へのアクセス</h2>

<p>ContentProvider へのアクセスは、ContentResolver を介して行うことは、<a href="/AndroidTraining/fundamentals/2.10.database.html">2.10. データベース</a>にて解説しました。このページの方法では、1 回のアクセスで 1 回の操作（挿入、更新、削除）を行うように動作します。</p>

<p>今回は、1 回のアクセスで複数の操作（挿入、更新、削除）を行う、バッチ処理について解説するとともに、ContentResolver 以外の手段を用いた ContentProvider へのアクセスについて解説します。</p>

<h3 id="section-1">バッチ処理</h3>

<p>ContentProviderOperation に、挿入・更新・削除のいずれかの処理のための情報をもたせ、このオブジェクトを List にまとめて ContentResolver 経由でリクエストすることで、バッチ処理が実行できます。</p>

<p>バッチ処理と同等のリクエストを複数回繰り返すよりも、バッチ処理の方が高速に動作します。一方で、バッチ処理はそのままではアトミック性を保証しないまま動作してしまうため、必要であれば<code class="highlighter-rouge">ContentProvider#applyBatch(ArrayList)</code>をオーバライドして、トランザクションを自分で開始・終了する必要があります。</p>

<p>以下に、挿入・更新・削除のそれぞれの処理を構成する ContentProviderOperation の作成例と、バッチ処理の適用方法を示します。</p>

<pre><code class="language-Java">public void batchInsert(Context context, List&lt;String&gt; names) {
    ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();

    // List に ContentProviderOperation を詰め込んで、バッチ処理時にすべてを実行するようにする
    for (String name : names) {
        ContentValues values = new ContentValues();
        values.put("name", name);

        // ContentProviderOperation#newInsert(Uri) によって、挿入に関する操作手順を生成するビルダーを取得する
        ContentProviderOperation insertOp = ContentProviderOperation.newInsert(MyContentProvider.CONTENT_URI)
                .withValues(values)  // ContentValues に含まれるデータを挿入
                .build();  // ContentProviderOperation を作成
        ops.add(insertOp);
    }

    ContentResolver resolver = context.getContentResolver();
    resolver.applyBatch(MyContentProvider.AUTHORITY, ops);  // バッチ処理を実行
}

public void batchUpdate(Context context, List&lt;Integer&gt; ids, List&lt;String&gt; names) {
    ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();

    for (int i = 0; i &lt; ids.size() &amp;&amp; i &lt; names.size(); i++) {
        Integer id = ids.get(i);
        String name = names.get(i);

        ContentValues values = new ContentValues();
        values.put("name", name);

        // ContentProviderOperation#newUpdate(Uri) によって、更新に関する操作手順を生成するビルダーを取得する
        ContentProviderOperation updateOp = ContentProviderOperation.newUpdate(MyContentProvider.CONTENT_URI)
                .withValues(values)
                .withSelection("_id = ?", new String[] { id.toString() })  // Update 対象の条件を付与
                .build();
        ops.add(updateOp);
    }

    ContentResolver resolver = context.getContentResolver();
    resolver.applyBatch(MyContentProvider.AUTHORITY, ops);  // バッチ処理を実行
}

public void batchDelete(Context context, List&lt;Integer&gt; ids) {
    ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();

    for (Integer id : ids) {
        // ContentProviderOperation#newUpdate(Uri) によって、削除に関する操作手順を生成するビルダーを取得する
        ContentProviderOperation deleteOp = ContentProviderOperation.newDelete(MyContentProvider.CONTENT_URI)
                .withSelection("_id = ?", new String[] { id.toString() })
                .build();
        ops.add(deleteOp);
    }

    ContentResolver resolver = context.getContentResolver();
    resolver.applyBatch(MyContentProvider.AUTHORITY, ops);
}
</code></pre>

<p>挿入・更新・削除とも、操作に合わせて呼び出すメソッドが異なりますが、それぞれで得られるオブジェクトの型はすべて ContentProviderOperation.Builder となります。操作に応じて、 ContentProviderOperation.Builder の各種メソッドで手順の設定の仕方が変わることに注意して下さい。例えば、<code class="highlighter-rouge">ContentProviderOperation#newInsert(Uri)</code> で生成した ContentProviderOperation.Builder では、<code class="highlighter-rouge">ContentProviderOperation.Builder#withSelection(String, String[])</code> が使用できず、実行時に<code class="highlighter-rouge">IllegalArgumentException</code>となります。</p>

<p>挿入・更新・削除の操作を複数含む ArrayList を生成すれば、バッチ処理中にそれらの手順をまとめて実行することもできます。</p>

<p>バッチ処理の実行は、<code class="highlighter-rouge">ContentResolver#applyBatch(String, ArrayList)</code>によって行い、返り値として、処理結果を表す<code class="highlighter-rouge">ContentProviderResult</code>の配列が得られます。</p>

<h3 id="intent-">Intent によるアクセス</h3>

<h2 id="section-2">データの同期</h2>

<p>しばしば、アプリケーションはサーバサイドとのデータのやり取りを密接にやりとりします。ネットワークにつながらない場所に居ても、最低限、それ以前にサーバからダウンロードしておいたデータへのアクセス性を確保したり、定期的にアプリケーション内に蓄積したデータをサーバへ送信することでバックアップを取ったりするような仕組みは、ネットワークへの接続が必ずしも常にあるとは限らない環境において、また、多様な端末を複数使用する環境においては、とても大切な仕組みとなります。</p>

<p>Android では、これらを支援する仕組みとして、クラウドとの同期のためのフレームワークを提供しています。今回は、特に ContentProvider を用いたフレームワークに注目して解説します。</p>

<p>ContentProvider 以外にも同期の仕組みが存在しますが、この仕組は<a href="/AndroidTraining/advanced/3.08.cloud-sync.html">3.08. クラウド同期</a>で解説します。</p>

<h3 id="contentprovider--1">ContentProvider を用いた同期の仕組み</h3>

<p>API Level 8 から、ContentProvider の保持しているデータを、<strong>定期的に</strong>サーバ（クラウド）と同期する仕組みが導入されました。端末の AccountManager で管理されているアカウントに紐付いて、同期の定期実行をシステムに促すことで、指定した間隔で同期を実行するようになります。</p>

<p>複数の ContentProvider を持つ場合、それぞれの ContentProvider で個別に同期処理を実行させることができます。この時、それぞれの同期処理は並列には実行されず、キューに積まれて順次同期処理が実行されます。このため、他の同期処理の影響を受けて、指定した間隔通りに同期処理が実行されないことがある点に注意して下さい。</p>

<h3 id="section-3">同期の仕組みを使用する準備</h3>

<p>AccountManager で管理されているアカウントが必要となるため、ContentProvider を用いたデータの同期をするには、Authenticator の使用が必要となります。既に Authenticator によるアカウント管理の仕組みがある場合は特に作業の必要はありませんが、アカウント管理の仕組みが必要でないアプリケーションでは、スタブの Authenticator を用意する必要があります。</p>

<p>以下がスタブの Authenticator の実装の例です。アカウント管理をしないのであれば、ロジックを記述せず、操作がサポートされない旨を表す<code class="highlighter-rouge">UnsupportedOperationException</code>をスローするようにします。</p>

<pre><code class="language-Java">public class StubAuthenticator extends AbstractAccountAuthenticator {
    public StubAuthenticator(Context context) {
        super(context);
    }

    @Override
    public Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options) throws NetworkErrorException {
        return null; // アカウント管理をしないため、null を返す
    }

    @Override
    public abstract Bundle confirmCredentials (AccountAuthenticatorResponse response, Account account, Bundle options) throws NetworkErrorException {
        return null; // アカウント生成の了承リクエストは無視するため、null を返す
    }

    @Override
    public abstract Bundle editProperties(AccountAuthenticatorResponse response, String accountType) {
        throw new UnsupportedOperationException("edit properties not supported"); // アカウント情報の編集は、アカウント管理をしないポリシーとなるので例外とする
    }

    @Override
    public abstract Bundle getAuthToken(AccountAuthenticatorResponse response, Account account, String authTokenType, Bundle options) throws NetowrkErrorException {
        throw new UnsupportedOperationException("get auth token not supported"); // トークン管理も、アカウント管理をしないため例外
    }

    @Override
    public abstract String getAuthTokenLabel(String authTokenType) {
        throw new UnsupportedOperationException("get auth token label not supported"); // トークン管理をしないので、トークンの種類に対応する表示も例外
    }

    @Override
    public abstract Bundle hasFeatures(AccountAuthenticatorResponse response, Account account, String[] features) throws NetworkErrorException {
        throw new UnsupportedOperationException("feature check not supported"); // アカウント管理をしないため例外
    }

    @Override
    public Bundle updateCredentials(AccountAuthenticatorResponse r, Account account, String s, Bundle bundle) throws NetworkErrorException {
        throw new UnsupportedOperationException(); // アカウント管理をしないため例外
    }
}
</code></pre>

<p>Authenticator の実装ができたら、Authenticator を動作させるための Service を実装します。</p>

<pre><code class="language-Java">public class StubAuthenticatorService extends Service {
    // スタブの Authenticator を保持しておく
    private StubAuthenticator mAuthenticator;
    @Override
    public void onCreate() {
        mAuthenticator = new StubAuthenticator(this);
    }

    // システムは、Authenticator に対して RPC を実施する為にこの Service にバインドするので、RPC のための IBinder を Authenticator から取得する
    @Override
    public IBinder onBind(Intent intent) {
        return mAuthenticator.getIBinder();
    }
}
</code></pre>

<p>次に、スタブの Authenticator に関するメタデータの宣言をします。</p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>意味</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>android:accountType</td>
      <td>アカウントの識別子。同期処理をシステムが管理する際にも、どのアカウントに紐づくものかを識別するために使用する。</td>
    </tr>
    <tr>
      <td>android:icon</td>
      <td>アカウントのアイコン。同期処理をユーザによって設定可能にする場合は必須。</td>
    </tr>
    <tr>
      <td>android:smallIcon</td>
      <td>スクリーンの大きさによって、<code class="highlighter-rouge">icon</code>属性に指定した画像のかわりに使用される。</td>
    </tr>
    <tr>
      <td>android:label</td>
      <td>アカウントの表示名。同期処理をユーザによって設定可能にする場合は必須。</td>
    </tr>
  </tbody>
</table>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="c">&lt;!-- res/xml/authenticator.xml --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;account-authenticator</span>
        <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
        <span class="na">android:accountType=</span><span class="s">"jp.co.mixi.sample.sync.stub.account"</span>
        <span class="na">android:icon=</span><span class="s">"@drawable/ic_launcher"</span>
        <span class="na">android:smallIcon=</span><span class="s">"@drawable/ic_launcher"</span>
        <span class="na">android:label=</span><span class="s">"@string/app_name"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<p>AndroidManifest には Service と同期処理を紐付ける ContentProvider を宣言します。</p>

<p>Service の宣言には、<code class="highlighter-rouge">&lt;intent-filter&gt;</code>と<code class="highlighter-rouge">&lt;meta-data&gt;</code>を含める必要があります。<br />
ContentProvider の宣言では、<code class="highlighter-rouge">android:syncable</code>属性を<code class="highlighter-rouge">true</code>にしておく必要があります。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;service</span>
    <span class="na">android:name=</span><span class="s">"jp.mixi.sample.sync.stub.authenticator.StubAuthenticatorService"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;intent-filter&gt;</span>
        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.accounts.AccountAuthenticator"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;meta-data</span>
        <span class="na">android:name=</span><span class="s">"android.accounts.AccountAuthenticator"</span>
        <span class="na">android:resource=</span><span class="s">"@xml/authenticator"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/service&gt;</span>

<span class="nt">&lt;provider</span>
    <span class="na">android:name=</span><span class="s">"jp.mixi.sample.sync.StubSyncProvider"</span>
    <span class="na">android:authorities=</span><span class="s">"jp.mixi.sample.sync.StubSyncProvider"</span>
    <span class="na">android:export=</span><span class="s">"false"</span>
    <span class="na">android:syncable=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<p>最後に、端末にアカウント情報を登録します。</p>

<pre><code class="language-Java">public class MainActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstancestate);
        setContentView(R.layout.activity_main);

        // ...
        Account account = createAccount();

    }

    private Account createAccount() {
        AccountManager manager = (AccountManager) getSystemService(Context.ACCOUNT_SERVICE);
        // スタブのアカウント情報を持つ Account オブジェクトを作る
        Account stubAccount = new Account("stubAccount", "jp.co.mixi.sample.sync.stub.account");

        // AccountManager にスタブのアカウント情報を登録
        if (manager.addAccountExplicitly(stubAccount, null, null)) {
            // 登録成功
        } else {
            // 既に登録されているか、アカウントが null、その他エラーの場合
        }
        return stubAccount;
    }
}
</code></pre>

<h3 id="abstractthreadedsyncadapter">AbstractThreadedSyncAdapter</h3>

<p>ContentProvider のデータの同期を目的としたクラスで、ContentResolver によって同期のタイミングが管理されます。</p>

<p>このクラスは、アプリケーションプロセスが実行中、ワーカスレッド上でクラウドとの同期処理を記述するフレームワークを提供しています。UI スレッドとは別のスレッド上で実行される為、各種の IO を同期的に記述しても問題ありません。</p>

<pre><code class="language-Java">public MySyncAdapter extends AbstractThreadedSyncAdapter {
    public MySyncAdapter(Context context, boolean autoInitialize) {
        super(context, autoInitialize);
    }

    /**
     * 定期実行処理が走った時に呼ばれるコールバック
     *
     * @param account 定期実行のリクエストが紐付けられているアカウント
     * @param extras 定期実行をシステムに登録した時に渡すパラメータを含むマップオブジェクト
     * @param authority ContentProvider の AUTHORITY
     * @param provider ContentProvider へのアクセサ
     * @param syncResult 同期処理の結果を保持するオブジェクト。成功・例外などの情報を持つ
     */
    @Override
    public void onPerformSync(Account account, Bundle extras, String authority, ContentProviderClient provider, SyncResult syncResult) {
        // ここに同期のための処理を記述する
    }
}
</code></pre>

<h3 id="service">Service</h3>

<p>データの同期のタイミングで呼び出され、AbstractThreadedSyncAdapter に記述した同期の手続きを実行するための Service を定義します。</p>

<p>AbstractThreadedSyncAdapter のインスタンスは、アプリケーションのライフサイクルの中で Singleton として扱うようにし、複数の AbstractThreadedSyncAdapter のインスタンスを生成して並列に同期を実行してしまうことを防ぎます。</p>

<pre><code class="language-Java">public MySyncService extends Service {
    private static AbstractThreadedSyncAdapter sAdapter;
    private static final Object LOCK = new Object();
    @Override
    public void onCreate() {
        synchronized (LOCK) {
            if (sAdapter == null) {
                sAdapter = new MySyncAdapter(getApplicationContext(), true);
            }
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return sAdapter.getSyncAdapterBinder();
    }
}
</code></pre>

<h3 id="section-4">メタデータの宣言</h3>

<p>AbstractThreadedSyncAdapter のためのメタデータを下記のように宣言します。</p>

<table>
  <thead>
    <tr>
      <th>属性名</th>
      <th>意味</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>android:contentAuthority</td>
      <td>ContentProvider の AUTHORITY を指定する。</td>
    </tr>
    <tr>
      <td>android:accountType</td>
      <td>Authenticator のメタデータに記述したアカウントの識別子を指定する。</td>
    </tr>
    <tr>
      <td>android:userVisible</td>
      <td>設定画面でユーザがこの同期処理をコントロール出来るようにするかどうか。</td>
    </tr>
    <tr>
      <td>android:supportsUploading</td>
      <td>同期中、データのアップロードをするかどうか。ダウンロードのみの場合は<code class="highlighter-rouge">false</code>とする。</td>
    </tr>
    <tr>
      <td>android:allowParallelSyncs</td>
      <td>複数の AbstractThreadedSyncAdapter のインスタンスから同時並行に同期処理を実行することを許すかどうか。複数アカウントを同じアプリケーションが管理する際に使用するため、単一のアカウントしかありえない場合は<code class="highlighter-rouge">false</code>とする。</td>
    </tr>
    <tr>
      <td>android:isAlwaysSyncable</td>
      <td>常に同期できるようにしておくかどうか。手動で設定出来るようにする場合は<code class="highlighter-rouge">false</code>とする。</td>
    </tr>
  </tbody>
</table>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="c">&lt;!-- res/xml/syncadapter.xml --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;sync-adapter</span>
    <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
    <span class="na">android:contentAuthority=</span><span class="s">"jp.mixi.sample.sync.StubSyncProvider"</span>
    <span class="na">android:accountType=</span><span class="s">"jp.co.mixi.sample.sync.stub.account"</span>
    <span class="na">android:userVisible=</span><span class="s">"false"</span>
    <span class="na">android:supportsUploading=</span><span class="s">"false"</span>
    <span class="na">android:allowParallelSyncs=</span><span class="s">"false"</span>
    <span class="na">android:isAlwaysSyncable=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<h3 id="androidmanifest-">AndroidManifest の宣言</h3>

<p>定期的な同期の実行は、Android が提供するフレームワークに則って実装し、自動的にフレームワークによって管理・実行されます。このため、定期的な同期の実行の仕組みを持つアプリケーションは、パーミッションの使用を宣言する必要があります。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;uses-permission</span>
        <span class="na">android:name=</span><span class="s">"android.permission.INTERNET"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;uses-permission</span>
        <span class="na">android:name=</span><span class="s">"android.permission.READ_SYNC_SETTINGS"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;uses-permission</span>
        <span class="na">android:name=</span><span class="s">"android.permission.WRITE_SYNC_SETTINGS"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;uses-permission</span>
        <span class="na">android:name=</span><span class="s">"android.permission.AUTHENTICATE_ACCOUNTS"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<p>次に、AbstractThreadedSyncAdapter を動かす Service を宣言します。この Service はシステムによって呼び出される為、<code class="highlighter-rouge">android:exported</code>を<code class="highlighter-rouge">true</code>にしておきます。</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;service</span>
    <span class="na">android:name=</span><span class="s">"com.example.android.datasync.SyncService"</span>
    <span class="na">android:exported=</span><span class="s">"true"</span>
    <span class="na">android:process=</span><span class="s">":sync"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;intent-filter&gt;</span>
        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">"android.content.SyncAdapter"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;meta-data</span>
        <span class="na">android:name=</span><span class="s">"android.content.SyncAdapter"</span>
        <span class="na">android:resource=</span><span class="s">"@xml/syncadapter"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/service&gt;</span>
</code></pre>
</div>

<h3 id="section-5">同期の実行と下位互換</h3>

<p>これまでは、同期に必要なコンポーネントの作り方を見てきましたが、これらを準備しただけでは同期が実行されるようにはなりません。<br />
アプリケーションの初回実行時に、システムに登録する必要があります。</p>

<p>定期実行する同期処理の登録には、ContentResolver を使用します。また、AccountManager に登録した Account に紐付けるため、Account も必要です。</p>

<h4 id="section-6">指定した間隔で同期する</h4>

<p>指定した間隔で同期するようシステムに登録するには、<code class="highlighter-rouge">ContentResolver#addPeriodicSync(Account, String, Bundle, long)</code>を使用します。</p>

<pre><code class="language-Java">/**
 * @param account 紐付けるアカウント
 * @param frequencySec 同期処理を実行する間隔(秒)
 */
public void applySyncPeriod(Account account, long frequencySec) {
    Bundle args = new Bundle(); // 同期処理の制御に関するパラメータを保持するマップオブジェクト
                                //何らか同期処理のために渡したいパラメータがある場合はこの Bundle に詰め込む
    ContentResolver.addPeriodicSync(account, StubContentProvider.AUTHORITY, args, frequencySec);
}
</code></pre>

<h4 id="section-7">ネットワークの状態に応じて同期する</h4>

<p>Android システムは、ネットワークの接続が確立されると、TCP/IP のコネクションを開いたままの状態に保つために、短い間隔でメッセージを創出し続けます。このメッセージの送出に合わせて同期する場合は、<code class="highlighter-rouge">ContentResolver#setSyncAutomatically(Account, String, boolean)</code>を使用して登録します。</p>

<pre><code class="language-Java">/**
 * @param account 紐付けるアカウント
 */
public void applySyncPeriod(Account account) {
    // 最後の boolean を true にすれば同期が有効となり、false にすれば同期が無効化される
    ContentResolver.setSyncAutomatically(account, StubContentProvider.AUTHORITY, true);   
}
</code></pre>

<p>短時間で頻繁に同期が実行されるようになりますが、この操作によって、<code class="highlighter-rouge">ContentResolver#addPeriodicSync(Account, String, Bundle, long)</code>によって登録された同期処理が無効化されるわけではありません。一定の間隔で実行すればよいものは、<code class="highlighter-rouge">ContentResolver#addPeriodicSync(Account, String, Bundle, long)</code>を用いるだけで事足ります。</p>

<h4 id="section-8">オンデマンドに同期する</h4>

<p>ボタンをおした時など、何かしらのイベントをトリガに同期を手動で実行したい時には、<code class="highlighter-rouge">ContentResolver#requestSync(Account, String, Bundle)</code>を使用します。</p>

<p>フレームワークは、定期的に実行するタイミングで効率よく処理を行えるようチューニングされているため、オンデマンドに同期処理を起動することは推奨されていません。また、データの同期が必要ない場合でも無理やり同期を実行させてしまうため、無駄にシステムのリソースを消費してしまう可能性があります。これらの理由から、オンデマンドに同期する機能の実装は推奨されていません。</p>

<pre><code class="language-Java">public void dispatchSync(Account account) {
    Bundle args = new Bundle();
    args.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true); // 手動で同期するフラグをシステムに伝える
    args.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true); // キューの先頭に積み、すぐに同期を実行するようシステムに伝える
    ContentResolver.requestSync(account, StubContentProvider.AUTHORITY, args);
}
</code></pre>

<h4 id="section-9">下位互換性</h4>

<p>ContentResolver が持つ各種の定期的な同期のためのメソッドは、API Level 8 から導入されました。一方で、AbstractThreadedSyncAdapter など、同期に使われるコンポーネントは API Level 5 から導入されています。このため、定期的に実行するようシステムに伝える部分を、API Level 7 以前の OS の為に自分で実装する必要があります。</p>

<p>単純な、一定間隔での同期の実行であれば、<code class="highlighter-rouge">AlarmManager</code>を用いて対応することができます。</p>

<pre><code class="language-Java">/**
 * @param account 紐付けるアカウント
 * @param frequencySec 同期処理を実行する間隔(秒)
 */
public void applySyncPeriod(Context context, Account account, long frequencySec) {
    Bundle args = new Bundle(); // 同期処理の制御に関するパラメータを保持するマップオブジェクト
                                //何らか同期処理のために渡したいパラメータがある場合はこの Bundle に詰め込む
    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.FROYO) {
        // AlarmManager ではミリ秒で管理されるのでミリ秒へ変換
        long frequencyMillis = frequencySec * 1000;

        // AlarmManager によって、定期的にブロードキャストされる Intent を準備する
        Intent intent = new Intent(SyncTriggerReceiver.ACTION_TRIGGER, Uri.parse("alarm:" + authority));
        intent.putExtra(SyncTriggerReceiver.EXTRA_SYNC_AUTHORITY, StubContentProvider.AUTHORITY);
        intent.putExtra(SyncTriggerReceiver.EXTRA_SYNC_ACCOUNT_NAME, account.name);
        intent.putExtra(SyncTriggerReceiver.EXTRA_SYNC_ACCOUNT_TYPE, account.type);
        intent.putExtra(SyncTriggerReceiver.EXTRA_SYNC_EXTRAS, extras);

        // AlarmManager によって Intent のハンドリングがなされるため、遅延させるために PendingIntent を作成        
        PendingIntent pendingOperation = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);

        // AlarmManager に登録
        AlarmManager manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        manager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + frequencyMillis, frequencyMillis, operation);
    } else {
        ContentResolver.addPeriodicSync(account, StubContentProvider.AUTHORITY, args, frequencySec);
    }
}
</code></pre>

<p>これに対応して、BroadcastReceiver を準備します。</p>

<pre><code class="language-Java">public class SyncTriggerReceiver extends BroadcastReceiver {
    public static final String ACTION_TRIGGER = "ACTION_TRIGGER";
    public static final String EXTRA_SYNC_AUTHORITY = "authority";
    public static final String EXTRA_SYNC_ACCOUNT_NAME = "account_name";
    public static final String EXTRA_SYNC_ACCOUNT_TYPE = "account_type";
    public static final String EXTRA_SYNC_EXTRAS = "extras";

    @Override
    public void onReceive(Context context, Intent intent) {
        if (ACTION_TRIGGER.equals(intent.getAction)) {
            String accountName = intent.getStringExtra(EXTRA_SYNC_ACCOUNT_NAME);
            String accountType = intent.getStringExtra(EXTRA_SYNC_ACCOUNT_TYPE);
            String authority = intent.getStringExtra(EXTRA_SYNC_AUTHORITY);
            Bundle extras = intent.getParcelableExtra(EXTRA_SYNC_EXTRAS);
            Account account = new Account(accountName, accountType);

            ContentResolver.requestSync(account, authority, extras);
        }
    }
}
</code></pre>

          </section>
        </div>

        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
          <footer class="inner">
  <p class="license">Portions of this page are reproduced from work created and <a href="https://code.google.com/p/android/">shared by the Android Open Source Project</a> and used according to terms described in the <a href="http://creativecommons.org/licenses/by/2.5/">Creative Commons2.5 Attribution License</a>.</p>
  <p class="license">
  This work is licensed under a <a rel="license" itemprop="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. 
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
  </p>
  <p class="copyright">Androidtraining maintained by <a href="https://github.com/mixi-inc" itemprop="author">mixi-inc</a></p>
  <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>

</footer>

        </div>
      </paper-scroll-header-panel>
    </paper-drawer-panel>
    <script>
        // custom transformation: scale header's title
        var title = document.querySelectorAll('.title')[2];
        addEventListener('paper-header-transform', function(e) {
            var d = e.detail;
            var m = d.height - d.condensedHeight;
            var scale = Math.max(0.75, (m - d.y) / (m / 0.25)  + 0.75);

            Polymer.Base.transform('scale(' + scale + ') translateZ(0)', title);
        });

    </script>
</body>
</html>
