---
title: AppBarとインタラクション制御
description: この章では、Android 標準の UI コンポーネントである AppBar と、インタラクション制御について解説します。
keywords: ["android","training", "基礎", "スキル", "開発", "developer", "プログラミング", "AppBar", "インタラクション制御"]

---

参考：UI デザインとしての[App Bar &#124; Android Developers](https://material.google.com/layout/structure.html#structure-app-bar)  
参考：プログラミングとしての[App Bar &#124; Android Developers](https://developer.android.com/training/appbar/index.html)

## AppBar
AppBar（Android での以前の名称はActionBar）は、ブランド表示、ナビゲーション、検索、各種操作などを配置できる特殊なツールバーです。  
AppBarの左側にあるナビゲーション アイコンは次のように使用できます。

- ナビゲーション ドロワーを開くためのコントロールにする。
- アプリ内の上の階層に移動するための上矢印にする。
- 現在の画面でナビゲーションが必要なければ表示しない。

![AppBar]({{site.baseurl}}/assets/02-05/layout_structure_appbar_structure1.png)

AppBarのタイトルは現在のページによって変わり、アプリのタイトル、ページのタイトル、ページのフィルタなどになります。

AppBarの右側にあるアイコンは、アプリに関連する操作です。メニューアイコンではオーバーフロー メニューが開いて、ヘルプ、設定、フィードバックなどの補助的な操作やメニュー項目が表示されます。

## Toolbar
Android 5.0 (Lollipop)と同時に追加されたActionBarの代替となるコンポーネントです。  
従来のActionBarに比べて、高さやレイアウトを自由に変えられる汎用的なコンポーネントです。  
Toolbarはヘッダー部分だけに使われるとは限りません。  

![]({{site.baseurl}}/assets/02-05/layout_structure_toolbars5.png)
![]({{site.baseurl}}/assets/02-05/layout_structure_toolbars7.png)

### ToolbarをAppBarとして使う
一般的な方法では、サポートライブラリのToolbarをAppBarとして使います。  
[https://developer.android.com/training/appbar/setting-up.html](https://developer.android.com/training/appbar/setting-up.html)

#### 1. projectに`v7 appcompat`を追加
```gradle
dependencies {
    compile 'com.android.support:appcompat-v7:24.2.1'
}
```

#### 2. `AppCompatActivity`を継承したActivityを作る  

```java
public class MyActivity extends AppCompatActivity {
  // ...
}
```

#### 3. manifestファイルのapplicationのテーマに`NoActionBar`を設定する
こうすることで、ネイティブのActionBarクラスが使われないようにします。  

```xml
<application android:theme="@style/Theme.AppCompat.Light.NoActionBar"/>
```

#### 4. ActivityのレイアウトにToolbarを追加する  
```xml
<android.support.v7.widget.Toolbar
   android:id="@+id/my_toolbar"
   android:layout_width="match_parent"
   android:layout_height="?attr/actionBarSize"
   android:background="?attr/colorPrimary"
   android:elevation="4dp"
   android:theme="@style/ThemeOverlay.AppCompat.ActionBar"
   app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>
```

#### 5. Activityの`onCreate`で`setSupportActionBar(Toolbar)`する
これによってToolbarがActivityのAppBarとして設定されます。  

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_my);
    Toolbar myToolbar = (Toolbar) findViewById(R.id.my_toolbar);
    setSupportActionBar(myToolbar);
}
```

ToolbarがActionBarとしてセットされたら、`getSupportActionBar()`でActionBarの各種メソッドを利用できるようになります。  

```java
getSupportActionBar().setTitle("New App");
```

### 戻るボタンをつける
Toolbarの左側に前の画面に戻るボタンを追加します。
<div><img src='{{site.baseurl}}/assets/02-05/toolbar_4.png' width='300px'></div>

```java
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
```

```java
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case android.R.id.home:
            finish();
            return true;

        default:
            return super.onOptionsItemSelected(item);
    }
}
```

### Action Buttonを追加する
<div><img src='{{site.baseurl}}/assets/02-05/toolbar_1.png' width='300px'></div>

#### 1. `menu/menu.xml` を作成
ActionButtonとして表示するボタン要素をxmlで定義します。

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android" >
    <item
        android:id="@+id/action_favorite"
        android:icon="@drawable/ic_favorite_black_48dp"
        android:title="@string/action_favorite"
        app:showAsAction="ifRoom"/>

    <item android:id="@+id/action_settings"
          android:title="@string/action_settings"
          app:showAsAction="never"/>
</menu>
```

#### 2. Action Buttonを表示
AppBarエリアにActionButtonを表示します。

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu, menu);
    return super.onCreateOptionsMenu(menu);
}
```

#### 3. ActionButtonタップ時のアクションをハンドリング
ActionButtonをタップした時の処理を設定します。

```java
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.action_settings:
            Toast.makeText(this, "setting", Toast.LENGTH_SHORT).show();
            return true;

        case R.id.action_favorite:
            Toast.makeText(this, "favorite", Toast.LENGTH_SHORT).show();
            return true;

        default:
            return super.onOptionsItemSelected(item);
    }
}
```

## インタラクション制御

### Activity や Fragment のコールバックメソッド

Activity と　Fragment には、メニューの構成と表示について、下記のような 2 種類のメニューを扱うコールバックメソッドが用意されています。

#### OptionsMenu
メニューキーで表示されるメニュー、また ActionBar に表示される ActionItem の構成を扱います。

下記のコールバックメソッドが用意されています。

| メソッド名 | 意味 |
|------|------|
| onPrepareOptionsMenu | OptionsMenu を表示する前に、メニュー要素の状態を管理するために呼び出される |
| onCreateOptionsMenu | OptionsMenu の構成を初期化するために、Activity や Fragment のライフサイクルの中で 1 度だけ呼ばれる |
| onOptionsItemSelected | OptionsMenu の選択状況を見て、適切なアクションを起こすために呼び出される |

```java
public class MainActivity extends Activity {
    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // ここで、状態に応じてメニューの有効・無効を切り替えたりなどの処理をする
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // ここで、この Activity で利用するメニューのリソースを読み込む
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // 選択されたメニューに対応するイベント処理をここで実行する
        return super.onOptionsItemSelected(item);
    }
}
```

#### ContextMenu
View の長押しで表示されるメニューの構成を扱います。
下記のコールバックメソッドが用意されています。

| メソッド名 | 意味 |
|------|------|
| onCreateContextMenu | ContextMenu の構成を初期化する |
| onContextItemSelected | ContextMenu の選択状況を見て、適切なアクションを起こすために呼び出される |

```java
public class MainActivity extends Activity {
    @Override
    protected void onStart() {
        super.onStart();

        // View に長押しメニュー用のコールバックを設定する
        // 実際には、View に OnCreateContextMenuListener を設定するだけ
        // 登録処理を Activity が肩代わりしている
        View helloWorld = findViewById(R.id.HelloWorld);
        registerForContextMenu(helloWorld);
    }

    @Override
    protected void onStop() {
        // View に設定した長押しメニュー用のコールバックを解除する
        View helloWorld = findViewById(R.id.HelloWorld);
        unregisterForContextMenu(helloWorld);

        super.onStop();
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        // ここで、長押しメニューで利用するメニューリソースを読み込む
        super.onCreateContextMenu(menu, v, menuInfo);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        // ここで、選択されたメニューリソースに対応するイベント処理を実行する
        return super.onContextItemSelected(item);
    }
}
```

### View の状態とコールバックメソッド

View には、以下のような「状態（State）」が定義されています。<br />
View の種類によって、取り得る状態は様々です。

状態名 | 意味
-----|-----
normal | 何もしていない
enabled | View がユーザ操作を受け付ける状態
focused | View がユーザ操作によってフォーカスを持っている状態
selected | View がユーザ操作によって選択されている状態
checked | View がユーザ操作によってチェックされている状態
pressed | View がユーザ操作によって押されている（クリックされている・タップされている）状態

これらそれぞれの状態について、Observer パターンでイベントを監視するための仕組みが用意されています。<br />
監視するためのオブジェクトの登録方法によっては、Activity のライフサイクルに合わせて監視オブジェクトの管理を剃る必要のあるものがあることに注意してください。

#### OnClickListener

View をタップした時に呼び出されるイベントを拾うための Observer です。

```java
view.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    }
});
```

#### OnLongClickListener

View を長押しした時に呼び出されるイベントを拾うための Observer です。<br />
長押しした時のイベント処理が適切に実行されたら、`true`を返します。

```java
view.setOnLongClickListener(new View.OnLongClickListener() {
    @Override
    public boolean onLongClick(View v) {
        return false;
    }
});
```

#### OnFocusChangedListener

View のフォーカスが移動した時のイベントを拾うための Observer です。

```java
view.setOnFocusChangeListener(new View.OnFocusChangeListener() {
    @Override
    public void onFocusChange(View v, boolean hasFocus) {
    }
});
```

#### OnCheckedChangeListener

CheckBox などで、チェック状態が変化した時のイベントを拾うための Observer です。

```java
CompoundButton checkBox = (CompoundButton) findViewById(R.id.HelloCheck);
checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
    }
});
```

#### TextWatcher

EditText などで、入力テキストが変更された時のイベントを拾うための Observer です。
こちらは、Activity や Fragment のライフサイクルに合わせて、適宜 View への登録と解除を行う必要があります。

```java
public class MainActivity extends Activity {
    private TextWatcher mTextWatcher = new TextWatcher() {
        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {}

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

        @Override
        public void afterTextChanged(Editable s) {}
    };

    @Override
    protected void onStart() {
        super.onStart();

        // ライフサイクルに合わせて、Observer オブジェクトを登録する
        TextView helloEdit = (TextView) findViewById(R.id.HelloEdit);
        helloEdit.addTextChangedListener(mTextWatcher);
    }

    @Override
    protected void onStop() {
        // ライフサイクルに合わせて、Observer オブジェクトを解除する
        TextView helloEdit = (TextView) findViewById(R.id.HelloEdit);
        helloEdit.removeTextChangedListener(mTextWatcher);

        super.onStop();
    }
}
```

## 実習・課題

### Toolbar

1. (実習) 実習用プロジェクトでToolbarを表示するようにしてください
2. (課題) 新しい Activity を作成し、その Activity の中で階層を戻るボタンを実装してください

### インタラクション制御

1. (実習) OptionsMenu に、以下の 3 つの項目を表示し、それぞれ選択時に、どのメニューが選択されたかを`Toast`で表示するようにしてください
  * Settings と表示するもの
  * Login と表示するもの
  * Refresh と表示するもの
2. (実習) ActionBarSherlock を参照する実習用プロジェクトで OptionsMenu を扱った場合の、OptionsMenu の表示のされ方の違いを、エミュレータを用いて、画面の大きさを元に考察してレポートに記述してください（`android:showAsAction`に`withText`をつけると違いが出てきます。）
3. (課題) OptionsMenu に、以下の 2 つの項目を表示し、そのうち一方の項目の有効／無効の状態を交互に切り替える処理を実装してください。
  * Settings と表示するもの
  * Refresh と表示するもの
4. (課題) TextWatcher を利用して、EditText に入力された文字数をカウントする TextView を作成してください。
